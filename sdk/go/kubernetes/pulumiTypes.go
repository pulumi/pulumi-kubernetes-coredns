// *** WARNING: this file was generated by Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package kubernetes

import (
	"context"
	"reflect"

	autoscalingv2beta2 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/autoscaling/v2beta2"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type CoreDNSAutoscaler struct {
	// Number of cores in the cluster per coredns replica.
	CoresPerReplica *int `pulumi:"coresPerReplica"`
	// Enabled the cluster-proportional-autoscaler.
	Enabled *bool `pulumi:"enabled"`
	// The image to pull from for the autoscaler.
	Image *CoreDNSImage `pulumi:"image"`
	// Whether to include unschedulable nodes in the nodes/cores calculations - this requires version 1.8.0+ of the autoscaler.
	IncludeUnschedulableNodes *bool `pulumi:"includeUnschedulableNodes"`
	// Max size of replicaCount
	Max *int `pulumi:"max"`
	// Min size of replicaCount
	Min *int `pulumi:"min"`
	// Number of nodes in the cluster per coredns replica.
	NodesPerReplica *int `pulumi:"nodesPerReplica"`
	// If true does not allow single points of failure to form.
	PreventSinglePointFailure *bool `pulumi:"preventSinglePointFailure"`
}

// CoreDNSAutoscalerInput is an input type that accepts CoreDNSAutoscalerArgs and CoreDNSAutoscalerOutput values.
// You can construct a concrete instance of `CoreDNSAutoscalerInput` via:
//
//          CoreDNSAutoscalerArgs{...}
type CoreDNSAutoscalerInput interface {
	pulumi.Input

	ToCoreDNSAutoscalerOutput() CoreDNSAutoscalerOutput
	ToCoreDNSAutoscalerOutputWithContext(context.Context) CoreDNSAutoscalerOutput
}

type CoreDNSAutoscalerArgs struct {
	// Number of cores in the cluster per coredns replica.
	CoresPerReplica pulumi.IntPtrInput `pulumi:"coresPerReplica"`
	// Enabled the cluster-proportional-autoscaler.
	Enabled pulumi.BoolPtrInput `pulumi:"enabled"`
	// The image to pull from for the autoscaler.
	Image CoreDNSImagePtrInput `pulumi:"image"`
	// Whether to include unschedulable nodes in the nodes/cores calculations - this requires version 1.8.0+ of the autoscaler.
	IncludeUnschedulableNodes pulumi.BoolPtrInput `pulumi:"includeUnschedulableNodes"`
	// Max size of replicaCount
	Max pulumi.IntPtrInput `pulumi:"max"`
	// Min size of replicaCount
	Min pulumi.IntPtrInput `pulumi:"min"`
	// Number of nodes in the cluster per coredns replica.
	NodesPerReplica pulumi.IntPtrInput `pulumi:"nodesPerReplica"`
	// If true does not allow single points of failure to form.
	PreventSinglePointFailure pulumi.BoolPtrInput `pulumi:"preventSinglePointFailure"`
}

func (CoreDNSAutoscalerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSAutoscaler)(nil)).Elem()
}

func (i CoreDNSAutoscalerArgs) ToCoreDNSAutoscalerOutput() CoreDNSAutoscalerOutput {
	return i.ToCoreDNSAutoscalerOutputWithContext(context.Background())
}

func (i CoreDNSAutoscalerArgs) ToCoreDNSAutoscalerOutputWithContext(ctx context.Context) CoreDNSAutoscalerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSAutoscalerOutput)
}

func (i CoreDNSAutoscalerArgs) ToCoreDNSAutoscalerPtrOutput() CoreDNSAutoscalerPtrOutput {
	return i.ToCoreDNSAutoscalerPtrOutputWithContext(context.Background())
}

func (i CoreDNSAutoscalerArgs) ToCoreDNSAutoscalerPtrOutputWithContext(ctx context.Context) CoreDNSAutoscalerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSAutoscalerOutput).ToCoreDNSAutoscalerPtrOutputWithContext(ctx)
}

// CoreDNSAutoscalerPtrInput is an input type that accepts CoreDNSAutoscalerArgs, CoreDNSAutoscalerPtr and CoreDNSAutoscalerPtrOutput values.
// You can construct a concrete instance of `CoreDNSAutoscalerPtrInput` via:
//
//          CoreDNSAutoscalerArgs{...}
//
//  or:
//
//          nil
type CoreDNSAutoscalerPtrInput interface {
	pulumi.Input

	ToCoreDNSAutoscalerPtrOutput() CoreDNSAutoscalerPtrOutput
	ToCoreDNSAutoscalerPtrOutputWithContext(context.Context) CoreDNSAutoscalerPtrOutput
}

type coreDNSAutoscalerPtrType CoreDNSAutoscalerArgs

func CoreDNSAutoscalerPtr(v *CoreDNSAutoscalerArgs) CoreDNSAutoscalerPtrInput {
	return (*coreDNSAutoscalerPtrType)(v)
}

func (*coreDNSAutoscalerPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSAutoscaler)(nil)).Elem()
}

func (i *coreDNSAutoscalerPtrType) ToCoreDNSAutoscalerPtrOutput() CoreDNSAutoscalerPtrOutput {
	return i.ToCoreDNSAutoscalerPtrOutputWithContext(context.Background())
}

func (i *coreDNSAutoscalerPtrType) ToCoreDNSAutoscalerPtrOutputWithContext(ctx context.Context) CoreDNSAutoscalerPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSAutoscalerPtrOutput)
}

type CoreDNSAutoscalerOutput struct{ *pulumi.OutputState }

func (CoreDNSAutoscalerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSAutoscaler)(nil)).Elem()
}

func (o CoreDNSAutoscalerOutput) ToCoreDNSAutoscalerOutput() CoreDNSAutoscalerOutput {
	return o
}

func (o CoreDNSAutoscalerOutput) ToCoreDNSAutoscalerOutputWithContext(ctx context.Context) CoreDNSAutoscalerOutput {
	return o
}

func (o CoreDNSAutoscalerOutput) ToCoreDNSAutoscalerPtrOutput() CoreDNSAutoscalerPtrOutput {
	return o.ToCoreDNSAutoscalerPtrOutputWithContext(context.Background())
}

func (o CoreDNSAutoscalerOutput) ToCoreDNSAutoscalerPtrOutputWithContext(ctx context.Context) CoreDNSAutoscalerPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSAutoscaler) *CoreDNSAutoscaler {
		return &v
	}).(CoreDNSAutoscalerPtrOutput)
}

// Number of cores in the cluster per coredns replica.
func (o CoreDNSAutoscalerOutput) CoresPerReplica() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *int { return v.CoresPerReplica }).(pulumi.IntPtrOutput)
}

// Enabled the cluster-proportional-autoscaler.
func (o CoreDNSAutoscalerOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// The image to pull from for the autoscaler.
func (o CoreDNSAutoscalerOutput) Image() CoreDNSImagePtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *CoreDNSImage { return v.Image }).(CoreDNSImagePtrOutput)
}

// Whether to include unschedulable nodes in the nodes/cores calculations - this requires version 1.8.0+ of the autoscaler.
func (o CoreDNSAutoscalerOutput) IncludeUnschedulableNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *bool { return v.IncludeUnschedulableNodes }).(pulumi.BoolPtrOutput)
}

// Max size of replicaCount
func (o CoreDNSAutoscalerOutput) Max() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *int { return v.Max }).(pulumi.IntPtrOutput)
}

// Min size of replicaCount
func (o CoreDNSAutoscalerOutput) Min() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *int { return v.Min }).(pulumi.IntPtrOutput)
}

// Number of nodes in the cluster per coredns replica.
func (o CoreDNSAutoscalerOutput) NodesPerReplica() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *int { return v.NodesPerReplica }).(pulumi.IntPtrOutput)
}

// If true does not allow single points of failure to form.
func (o CoreDNSAutoscalerOutput) PreventSinglePointFailure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSAutoscaler) *bool { return v.PreventSinglePointFailure }).(pulumi.BoolPtrOutput)
}

type CoreDNSAutoscalerPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSAutoscalerPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSAutoscaler)(nil)).Elem()
}

func (o CoreDNSAutoscalerPtrOutput) ToCoreDNSAutoscalerPtrOutput() CoreDNSAutoscalerPtrOutput {
	return o
}

func (o CoreDNSAutoscalerPtrOutput) ToCoreDNSAutoscalerPtrOutputWithContext(ctx context.Context) CoreDNSAutoscalerPtrOutput {
	return o
}

func (o CoreDNSAutoscalerPtrOutput) Elem() CoreDNSAutoscalerOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) CoreDNSAutoscaler {
		if v != nil {
			return *v
		}
		var ret CoreDNSAutoscaler
		return ret
	}).(CoreDNSAutoscalerOutput)
}

// Number of cores in the cluster per coredns replica.
func (o CoreDNSAutoscalerPtrOutput) CoresPerReplica() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *int {
		if v == nil {
			return nil
		}
		return v.CoresPerReplica
	}).(pulumi.IntPtrOutput)
}

// Enabled the cluster-proportional-autoscaler.
func (o CoreDNSAutoscalerPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// The image to pull from for the autoscaler.
func (o CoreDNSAutoscalerPtrOutput) Image() CoreDNSImagePtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *CoreDNSImage {
		if v == nil {
			return nil
		}
		return v.Image
	}).(CoreDNSImagePtrOutput)
}

// Whether to include unschedulable nodes in the nodes/cores calculations - this requires version 1.8.0+ of the autoscaler.
func (o CoreDNSAutoscalerPtrOutput) IncludeUnschedulableNodes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *bool {
		if v == nil {
			return nil
		}
		return v.IncludeUnschedulableNodes
	}).(pulumi.BoolPtrOutput)
}

// Max size of replicaCount
func (o CoreDNSAutoscalerPtrOutput) Max() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *int {
		if v == nil {
			return nil
		}
		return v.Max
	}).(pulumi.IntPtrOutput)
}

// Min size of replicaCount
func (o CoreDNSAutoscalerPtrOutput) Min() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *int {
		if v == nil {
			return nil
		}
		return v.Min
	}).(pulumi.IntPtrOutput)
}

// Number of nodes in the cluster per coredns replica.
func (o CoreDNSAutoscalerPtrOutput) NodesPerReplica() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *int {
		if v == nil {
			return nil
		}
		return v.NodesPerReplica
	}).(pulumi.IntPtrOutput)
}

// If true does not allow single points of failure to form.
func (o CoreDNSAutoscalerPtrOutput) PreventSinglePointFailure() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSAutoscaler) *bool {
		if v == nil {
			return nil
		}
		return v.PreventSinglePointFailure
	}).(pulumi.BoolPtrOutput)
}

type CoreDNSDeployment struct {
	// Optionally disable the main deployment and its respective resources.
	Enabled *bool `pulumi:"enabled"`
	// Name of the deployment if deployment.enabled is true. Otherwise the name of an existing deployment for the autoscaler or HPA to target.
	Name *string `pulumi:"name"`
}

// CoreDNSDeploymentInput is an input type that accepts CoreDNSDeploymentArgs and CoreDNSDeploymentOutput values.
// You can construct a concrete instance of `CoreDNSDeploymentInput` via:
//
//          CoreDNSDeploymentArgs{...}
type CoreDNSDeploymentInput interface {
	pulumi.Input

	ToCoreDNSDeploymentOutput() CoreDNSDeploymentOutput
	ToCoreDNSDeploymentOutputWithContext(context.Context) CoreDNSDeploymentOutput
}

type CoreDNSDeploymentArgs struct {
	// Optionally disable the main deployment and its respective resources.
	Enabled pulumi.BoolPtrInput `pulumi:"enabled"`
	// Name of the deployment if deployment.enabled is true. Otherwise the name of an existing deployment for the autoscaler or HPA to target.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CoreDNSDeploymentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSDeployment)(nil)).Elem()
}

func (i CoreDNSDeploymentArgs) ToCoreDNSDeploymentOutput() CoreDNSDeploymentOutput {
	return i.ToCoreDNSDeploymentOutputWithContext(context.Background())
}

func (i CoreDNSDeploymentArgs) ToCoreDNSDeploymentOutputWithContext(ctx context.Context) CoreDNSDeploymentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSDeploymentOutput)
}

func (i CoreDNSDeploymentArgs) ToCoreDNSDeploymentPtrOutput() CoreDNSDeploymentPtrOutput {
	return i.ToCoreDNSDeploymentPtrOutputWithContext(context.Background())
}

func (i CoreDNSDeploymentArgs) ToCoreDNSDeploymentPtrOutputWithContext(ctx context.Context) CoreDNSDeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSDeploymentOutput).ToCoreDNSDeploymentPtrOutputWithContext(ctx)
}

// CoreDNSDeploymentPtrInput is an input type that accepts CoreDNSDeploymentArgs, CoreDNSDeploymentPtr and CoreDNSDeploymentPtrOutput values.
// You can construct a concrete instance of `CoreDNSDeploymentPtrInput` via:
//
//          CoreDNSDeploymentArgs{...}
//
//  or:
//
//          nil
type CoreDNSDeploymentPtrInput interface {
	pulumi.Input

	ToCoreDNSDeploymentPtrOutput() CoreDNSDeploymentPtrOutput
	ToCoreDNSDeploymentPtrOutputWithContext(context.Context) CoreDNSDeploymentPtrOutput
}

type coreDNSDeploymentPtrType CoreDNSDeploymentArgs

func CoreDNSDeploymentPtr(v *CoreDNSDeploymentArgs) CoreDNSDeploymentPtrInput {
	return (*coreDNSDeploymentPtrType)(v)
}

func (*coreDNSDeploymentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSDeployment)(nil)).Elem()
}

func (i *coreDNSDeploymentPtrType) ToCoreDNSDeploymentPtrOutput() CoreDNSDeploymentPtrOutput {
	return i.ToCoreDNSDeploymentPtrOutputWithContext(context.Background())
}

func (i *coreDNSDeploymentPtrType) ToCoreDNSDeploymentPtrOutputWithContext(ctx context.Context) CoreDNSDeploymentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSDeploymentPtrOutput)
}

type CoreDNSDeploymentOutput struct{ *pulumi.OutputState }

func (CoreDNSDeploymentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSDeployment)(nil)).Elem()
}

func (o CoreDNSDeploymentOutput) ToCoreDNSDeploymentOutput() CoreDNSDeploymentOutput {
	return o
}

func (o CoreDNSDeploymentOutput) ToCoreDNSDeploymentOutputWithContext(ctx context.Context) CoreDNSDeploymentOutput {
	return o
}

func (o CoreDNSDeploymentOutput) ToCoreDNSDeploymentPtrOutput() CoreDNSDeploymentPtrOutput {
	return o.ToCoreDNSDeploymentPtrOutputWithContext(context.Background())
}

func (o CoreDNSDeploymentOutput) ToCoreDNSDeploymentPtrOutputWithContext(ctx context.Context) CoreDNSDeploymentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSDeployment) *CoreDNSDeployment {
		return &v
	}).(CoreDNSDeploymentPtrOutput)
}

// Optionally disable the main deployment and its respective resources.
func (o CoreDNSDeploymentOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSDeployment) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// Name of the deployment if deployment.enabled is true. Otherwise the name of an existing deployment for the autoscaler or HPA to target.
func (o CoreDNSDeploymentOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSDeployment) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CoreDNSDeploymentPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSDeploymentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSDeployment)(nil)).Elem()
}

func (o CoreDNSDeploymentPtrOutput) ToCoreDNSDeploymentPtrOutput() CoreDNSDeploymentPtrOutput {
	return o
}

func (o CoreDNSDeploymentPtrOutput) ToCoreDNSDeploymentPtrOutputWithContext(ctx context.Context) CoreDNSDeploymentPtrOutput {
	return o
}

func (o CoreDNSDeploymentPtrOutput) Elem() CoreDNSDeploymentOutput {
	return o.ApplyT(func(v *CoreDNSDeployment) CoreDNSDeployment {
		if v != nil {
			return *v
		}
		var ret CoreDNSDeployment
		return ret
	}).(CoreDNSDeploymentOutput)
}

// Optionally disable the main deployment and its respective resources.
func (o CoreDNSDeploymentPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSDeployment) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// Name of the deployment if deployment.enabled is true. Otherwise the name of an existing deployment for the autoscaler or HPA to target.
func (o CoreDNSDeploymentPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSDeployment) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type CoreDNSHPA struct {
	Enabled     *bool                          `pulumi:"enabled"`
	MaxReplicas *int                           `pulumi:"maxReplicas"`
	Metrics     *autoscalingv2beta2.MetricSpec `pulumi:"metrics"`
	MinReplicas *int                           `pulumi:"minReplicas"`
}

// CoreDNSHPAInput is an input type that accepts CoreDNSHPAArgs and CoreDNSHPAOutput values.
// You can construct a concrete instance of `CoreDNSHPAInput` via:
//
//          CoreDNSHPAArgs{...}
type CoreDNSHPAInput interface {
	pulumi.Input

	ToCoreDNSHPAOutput() CoreDNSHPAOutput
	ToCoreDNSHPAOutputWithContext(context.Context) CoreDNSHPAOutput
}

type CoreDNSHPAArgs struct {
	Enabled     pulumi.BoolPtrInput                   `pulumi:"enabled"`
	MaxReplicas pulumi.IntPtrInput                    `pulumi:"maxReplicas"`
	Metrics     autoscalingv2beta2.MetricSpecPtrInput `pulumi:"metrics"`
	MinReplicas pulumi.IntPtrInput                    `pulumi:"minReplicas"`
}

func (CoreDNSHPAArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSHPA)(nil)).Elem()
}

func (i CoreDNSHPAArgs) ToCoreDNSHPAOutput() CoreDNSHPAOutput {
	return i.ToCoreDNSHPAOutputWithContext(context.Background())
}

func (i CoreDNSHPAArgs) ToCoreDNSHPAOutputWithContext(ctx context.Context) CoreDNSHPAOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSHPAOutput)
}

func (i CoreDNSHPAArgs) ToCoreDNSHPAPtrOutput() CoreDNSHPAPtrOutput {
	return i.ToCoreDNSHPAPtrOutputWithContext(context.Background())
}

func (i CoreDNSHPAArgs) ToCoreDNSHPAPtrOutputWithContext(ctx context.Context) CoreDNSHPAPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSHPAOutput).ToCoreDNSHPAPtrOutputWithContext(ctx)
}

// CoreDNSHPAPtrInput is an input type that accepts CoreDNSHPAArgs, CoreDNSHPAPtr and CoreDNSHPAPtrOutput values.
// You can construct a concrete instance of `CoreDNSHPAPtrInput` via:
//
//          CoreDNSHPAArgs{...}
//
//  or:
//
//          nil
type CoreDNSHPAPtrInput interface {
	pulumi.Input

	ToCoreDNSHPAPtrOutput() CoreDNSHPAPtrOutput
	ToCoreDNSHPAPtrOutputWithContext(context.Context) CoreDNSHPAPtrOutput
}

type coreDNSHPAPtrType CoreDNSHPAArgs

func CoreDNSHPAPtr(v *CoreDNSHPAArgs) CoreDNSHPAPtrInput {
	return (*coreDNSHPAPtrType)(v)
}

func (*coreDNSHPAPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSHPA)(nil)).Elem()
}

func (i *coreDNSHPAPtrType) ToCoreDNSHPAPtrOutput() CoreDNSHPAPtrOutput {
	return i.ToCoreDNSHPAPtrOutputWithContext(context.Background())
}

func (i *coreDNSHPAPtrType) ToCoreDNSHPAPtrOutputWithContext(ctx context.Context) CoreDNSHPAPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSHPAPtrOutput)
}

type CoreDNSHPAOutput struct{ *pulumi.OutputState }

func (CoreDNSHPAOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSHPA)(nil)).Elem()
}

func (o CoreDNSHPAOutput) ToCoreDNSHPAOutput() CoreDNSHPAOutput {
	return o
}

func (o CoreDNSHPAOutput) ToCoreDNSHPAOutputWithContext(ctx context.Context) CoreDNSHPAOutput {
	return o
}

func (o CoreDNSHPAOutput) ToCoreDNSHPAPtrOutput() CoreDNSHPAPtrOutput {
	return o.ToCoreDNSHPAPtrOutputWithContext(context.Background())
}

func (o CoreDNSHPAOutput) ToCoreDNSHPAPtrOutputWithContext(ctx context.Context) CoreDNSHPAPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSHPA) *CoreDNSHPA {
		return &v
	}).(CoreDNSHPAPtrOutput)
}

func (o CoreDNSHPAOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSHPA) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

func (o CoreDNSHPAOutput) MaxReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSHPA) *int { return v.MaxReplicas }).(pulumi.IntPtrOutput)
}

func (o CoreDNSHPAOutput) Metrics() autoscalingv2beta2.MetricSpecPtrOutput {
	return o.ApplyT(func(v CoreDNSHPA) *autoscalingv2beta2.MetricSpec { return v.Metrics }).(autoscalingv2beta2.MetricSpecPtrOutput)
}

func (o CoreDNSHPAOutput) MinReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSHPA) *int { return v.MinReplicas }).(pulumi.IntPtrOutput)
}

type CoreDNSHPAPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSHPAPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSHPA)(nil)).Elem()
}

func (o CoreDNSHPAPtrOutput) ToCoreDNSHPAPtrOutput() CoreDNSHPAPtrOutput {
	return o
}

func (o CoreDNSHPAPtrOutput) ToCoreDNSHPAPtrOutputWithContext(ctx context.Context) CoreDNSHPAPtrOutput {
	return o
}

func (o CoreDNSHPAPtrOutput) Elem() CoreDNSHPAOutput {
	return o.ApplyT(func(v *CoreDNSHPA) CoreDNSHPA {
		if v != nil {
			return *v
		}
		var ret CoreDNSHPA
		return ret
	}).(CoreDNSHPAOutput)
}

func (o CoreDNSHPAPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSHPA) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

func (o CoreDNSHPAPtrOutput) MaxReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CoreDNSHPA) *int {
		if v == nil {
			return nil
		}
		return v.MaxReplicas
	}).(pulumi.IntPtrOutput)
}

func (o CoreDNSHPAPtrOutput) Metrics() autoscalingv2beta2.MetricSpecPtrOutput {
	return o.ApplyT(func(v *CoreDNSHPA) *autoscalingv2beta2.MetricSpec {
		if v == nil {
			return nil
		}
		return v.Metrics
	}).(autoscalingv2beta2.MetricSpecPtrOutput)
}

func (o CoreDNSHPAPtrOutput) MinReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CoreDNSHPA) *int {
		if v == nil {
			return nil
		}
		return v.MinReplicas
	}).(pulumi.IntPtrOutput)
}

type CoreDNSImage struct {
	// Image pull policy.
	PullPolicy *string `pulumi:"pullPolicy"`
	// Specify container image pull secrets.
	PullSecrets []string `pulumi:"pullSecrets"`
	// The image repository to pull from.
	Repository *string `pulumi:"repository"`
	// The image tag to pull from.
	Tag *string `pulumi:"tag"`
}

// CoreDNSImageInput is an input type that accepts CoreDNSImageArgs and CoreDNSImageOutput values.
// You can construct a concrete instance of `CoreDNSImageInput` via:
//
//          CoreDNSImageArgs{...}
type CoreDNSImageInput interface {
	pulumi.Input

	ToCoreDNSImageOutput() CoreDNSImageOutput
	ToCoreDNSImageOutputWithContext(context.Context) CoreDNSImageOutput
}

type CoreDNSImageArgs struct {
	// Image pull policy.
	PullPolicy pulumi.StringPtrInput `pulumi:"pullPolicy"`
	// Specify container image pull secrets.
	PullSecrets pulumi.StringArrayInput `pulumi:"pullSecrets"`
	// The image repository to pull from.
	Repository pulumi.StringPtrInput `pulumi:"repository"`
	// The image tag to pull from.
	Tag pulumi.StringPtrInput `pulumi:"tag"`
}

func (CoreDNSImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSImage)(nil)).Elem()
}

func (i CoreDNSImageArgs) ToCoreDNSImageOutput() CoreDNSImageOutput {
	return i.ToCoreDNSImageOutputWithContext(context.Background())
}

func (i CoreDNSImageArgs) ToCoreDNSImageOutputWithContext(ctx context.Context) CoreDNSImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSImageOutput)
}

func (i CoreDNSImageArgs) ToCoreDNSImagePtrOutput() CoreDNSImagePtrOutput {
	return i.ToCoreDNSImagePtrOutputWithContext(context.Background())
}

func (i CoreDNSImageArgs) ToCoreDNSImagePtrOutputWithContext(ctx context.Context) CoreDNSImagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSImageOutput).ToCoreDNSImagePtrOutputWithContext(ctx)
}

// CoreDNSImagePtrInput is an input type that accepts CoreDNSImageArgs, CoreDNSImagePtr and CoreDNSImagePtrOutput values.
// You can construct a concrete instance of `CoreDNSImagePtrInput` via:
//
//          CoreDNSImageArgs{...}
//
//  or:
//
//          nil
type CoreDNSImagePtrInput interface {
	pulumi.Input

	ToCoreDNSImagePtrOutput() CoreDNSImagePtrOutput
	ToCoreDNSImagePtrOutputWithContext(context.Context) CoreDNSImagePtrOutput
}

type coreDNSImagePtrType CoreDNSImageArgs

func CoreDNSImagePtr(v *CoreDNSImageArgs) CoreDNSImagePtrInput {
	return (*coreDNSImagePtrType)(v)
}

func (*coreDNSImagePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSImage)(nil)).Elem()
}

func (i *coreDNSImagePtrType) ToCoreDNSImagePtrOutput() CoreDNSImagePtrOutput {
	return i.ToCoreDNSImagePtrOutputWithContext(context.Background())
}

func (i *coreDNSImagePtrType) ToCoreDNSImagePtrOutputWithContext(ctx context.Context) CoreDNSImagePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSImagePtrOutput)
}

type CoreDNSImageOutput struct{ *pulumi.OutputState }

func (CoreDNSImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSImage)(nil)).Elem()
}

func (o CoreDNSImageOutput) ToCoreDNSImageOutput() CoreDNSImageOutput {
	return o
}

func (o CoreDNSImageOutput) ToCoreDNSImageOutputWithContext(ctx context.Context) CoreDNSImageOutput {
	return o
}

func (o CoreDNSImageOutput) ToCoreDNSImagePtrOutput() CoreDNSImagePtrOutput {
	return o.ToCoreDNSImagePtrOutputWithContext(context.Background())
}

func (o CoreDNSImageOutput) ToCoreDNSImagePtrOutputWithContext(ctx context.Context) CoreDNSImagePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSImage) *CoreDNSImage {
		return &v
	}).(CoreDNSImagePtrOutput)
}

// Image pull policy.
func (o CoreDNSImageOutput) PullPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSImage) *string { return v.PullPolicy }).(pulumi.StringPtrOutput)
}

// Specify container image pull secrets.
func (o CoreDNSImageOutput) PullSecrets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreDNSImage) []string { return v.PullSecrets }).(pulumi.StringArrayOutput)
}

// The image repository to pull from.
func (o CoreDNSImageOutput) Repository() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSImage) *string { return v.Repository }).(pulumi.StringPtrOutput)
}

// The image tag to pull from.
func (o CoreDNSImageOutput) Tag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSImage) *string { return v.Tag }).(pulumi.StringPtrOutput)
}

type CoreDNSImagePtrOutput struct{ *pulumi.OutputState }

func (CoreDNSImagePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSImage)(nil)).Elem()
}

func (o CoreDNSImagePtrOutput) ToCoreDNSImagePtrOutput() CoreDNSImagePtrOutput {
	return o
}

func (o CoreDNSImagePtrOutput) ToCoreDNSImagePtrOutputWithContext(ctx context.Context) CoreDNSImagePtrOutput {
	return o
}

func (o CoreDNSImagePtrOutput) Elem() CoreDNSImageOutput {
	return o.ApplyT(func(v *CoreDNSImage) CoreDNSImage {
		if v != nil {
			return *v
		}
		var ret CoreDNSImage
		return ret
	}).(CoreDNSImageOutput)
}

// Image pull policy.
func (o CoreDNSImagePtrOutput) PullPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSImage) *string {
		if v == nil {
			return nil
		}
		return v.PullPolicy
	}).(pulumi.StringPtrOutput)
}

// Specify container image pull secrets.
func (o CoreDNSImagePtrOutput) PullSecrets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CoreDNSImage) []string {
		if v == nil {
			return nil
		}
		return v.PullSecrets
	}).(pulumi.StringArrayOutput)
}

// The image repository to pull from.
func (o CoreDNSImagePtrOutput) Repository() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSImage) *string {
		if v == nil {
			return nil
		}
		return v.Repository
	}).(pulumi.StringPtrOutput)
}

// The image tag to pull from.
func (o CoreDNSImagePtrOutput) Tag() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSImage) *string {
		if v == nil {
			return nil
		}
		return v.Tag
	}).(pulumi.StringPtrOutput)
}

type CoreDNSPrometheus struct {
	Monitor *CoreDNSPrometheusMonitor `pulumi:"monitor"`
	Service *CoreDNSPrometheusService `pulumi:"service"`
}

// CoreDNSPrometheusInput is an input type that accepts CoreDNSPrometheusArgs and CoreDNSPrometheusOutput values.
// You can construct a concrete instance of `CoreDNSPrometheusInput` via:
//
//          CoreDNSPrometheusArgs{...}
type CoreDNSPrometheusInput interface {
	pulumi.Input

	ToCoreDNSPrometheusOutput() CoreDNSPrometheusOutput
	ToCoreDNSPrometheusOutputWithContext(context.Context) CoreDNSPrometheusOutput
}

type CoreDNSPrometheusArgs struct {
	Monitor CoreDNSPrometheusMonitorPtrInput `pulumi:"monitor"`
	Service CoreDNSPrometheusServicePtrInput `pulumi:"service"`
}

func (CoreDNSPrometheusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSPrometheus)(nil)).Elem()
}

func (i CoreDNSPrometheusArgs) ToCoreDNSPrometheusOutput() CoreDNSPrometheusOutput {
	return i.ToCoreDNSPrometheusOutputWithContext(context.Background())
}

func (i CoreDNSPrometheusArgs) ToCoreDNSPrometheusOutputWithContext(ctx context.Context) CoreDNSPrometheusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusOutput)
}

func (i CoreDNSPrometheusArgs) ToCoreDNSPrometheusPtrOutput() CoreDNSPrometheusPtrOutput {
	return i.ToCoreDNSPrometheusPtrOutputWithContext(context.Background())
}

func (i CoreDNSPrometheusArgs) ToCoreDNSPrometheusPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusOutput).ToCoreDNSPrometheusPtrOutputWithContext(ctx)
}

// CoreDNSPrometheusPtrInput is an input type that accepts CoreDNSPrometheusArgs, CoreDNSPrometheusPtr and CoreDNSPrometheusPtrOutput values.
// You can construct a concrete instance of `CoreDNSPrometheusPtrInput` via:
//
//          CoreDNSPrometheusArgs{...}
//
//  or:
//
//          nil
type CoreDNSPrometheusPtrInput interface {
	pulumi.Input

	ToCoreDNSPrometheusPtrOutput() CoreDNSPrometheusPtrOutput
	ToCoreDNSPrometheusPtrOutputWithContext(context.Context) CoreDNSPrometheusPtrOutput
}

type coreDNSPrometheusPtrType CoreDNSPrometheusArgs

func CoreDNSPrometheusPtr(v *CoreDNSPrometheusArgs) CoreDNSPrometheusPtrInput {
	return (*coreDNSPrometheusPtrType)(v)
}

func (*coreDNSPrometheusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSPrometheus)(nil)).Elem()
}

func (i *coreDNSPrometheusPtrType) ToCoreDNSPrometheusPtrOutput() CoreDNSPrometheusPtrOutput {
	return i.ToCoreDNSPrometheusPtrOutputWithContext(context.Background())
}

func (i *coreDNSPrometheusPtrType) ToCoreDNSPrometheusPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusPtrOutput)
}

type CoreDNSPrometheusOutput struct{ *pulumi.OutputState }

func (CoreDNSPrometheusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSPrometheus)(nil)).Elem()
}

func (o CoreDNSPrometheusOutput) ToCoreDNSPrometheusOutput() CoreDNSPrometheusOutput {
	return o
}

func (o CoreDNSPrometheusOutput) ToCoreDNSPrometheusOutputWithContext(ctx context.Context) CoreDNSPrometheusOutput {
	return o
}

func (o CoreDNSPrometheusOutput) ToCoreDNSPrometheusPtrOutput() CoreDNSPrometheusPtrOutput {
	return o.ToCoreDNSPrometheusPtrOutputWithContext(context.Background())
}

func (o CoreDNSPrometheusOutput) ToCoreDNSPrometheusPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSPrometheus) *CoreDNSPrometheus {
		return &v
	}).(CoreDNSPrometheusPtrOutput)
}

func (o CoreDNSPrometheusOutput) Monitor() CoreDNSPrometheusMonitorPtrOutput {
	return o.ApplyT(func(v CoreDNSPrometheus) *CoreDNSPrometheusMonitor { return v.Monitor }).(CoreDNSPrometheusMonitorPtrOutput)
}

func (o CoreDNSPrometheusOutput) Service() CoreDNSPrometheusServicePtrOutput {
	return o.ApplyT(func(v CoreDNSPrometheus) *CoreDNSPrometheusService { return v.Service }).(CoreDNSPrometheusServicePtrOutput)
}

type CoreDNSPrometheusPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSPrometheusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSPrometheus)(nil)).Elem()
}

func (o CoreDNSPrometheusPtrOutput) ToCoreDNSPrometheusPtrOutput() CoreDNSPrometheusPtrOutput {
	return o
}

func (o CoreDNSPrometheusPtrOutput) ToCoreDNSPrometheusPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusPtrOutput {
	return o
}

func (o CoreDNSPrometheusPtrOutput) Elem() CoreDNSPrometheusOutput {
	return o.ApplyT(func(v *CoreDNSPrometheus) CoreDNSPrometheus {
		if v != nil {
			return *v
		}
		var ret CoreDNSPrometheus
		return ret
	}).(CoreDNSPrometheusOutput)
}

func (o CoreDNSPrometheusPtrOutput) Monitor() CoreDNSPrometheusMonitorPtrOutput {
	return o.ApplyT(func(v *CoreDNSPrometheus) *CoreDNSPrometheusMonitor {
		if v == nil {
			return nil
		}
		return v.Monitor
	}).(CoreDNSPrometheusMonitorPtrOutput)
}

func (o CoreDNSPrometheusPtrOutput) Service() CoreDNSPrometheusServicePtrOutput {
	return o.ApplyT(func(v *CoreDNSPrometheus) *CoreDNSPrometheusService {
		if v == nil {
			return nil
		}
		return v.Service
	}).(CoreDNSPrometheusServicePtrOutput)
}

type CoreDNSPrometheusMonitor struct {
	// Additional labels that can be used so ServiceMonitor will be discovered by Prometheus.
	AdditionalLabels map[string]string `pulumi:"additionalLabels"`
	// Set this to true to create ServiceMonitor for Prometheus operator.
	Enabled *bool `pulumi:"enabled"`
	// Selector to select which namespaces the Endpoints objects are discovered from.
	Namespace *string `pulumi:"namespace"`
}

// CoreDNSPrometheusMonitorInput is an input type that accepts CoreDNSPrometheusMonitorArgs and CoreDNSPrometheusMonitorOutput values.
// You can construct a concrete instance of `CoreDNSPrometheusMonitorInput` via:
//
//          CoreDNSPrometheusMonitorArgs{...}
type CoreDNSPrometheusMonitorInput interface {
	pulumi.Input

	ToCoreDNSPrometheusMonitorOutput() CoreDNSPrometheusMonitorOutput
	ToCoreDNSPrometheusMonitorOutputWithContext(context.Context) CoreDNSPrometheusMonitorOutput
}

type CoreDNSPrometheusMonitorArgs struct {
	// Additional labels that can be used so ServiceMonitor will be discovered by Prometheus.
	AdditionalLabels pulumi.StringMapInput `pulumi:"additionalLabels"`
	// Set this to true to create ServiceMonitor for Prometheus operator.
	Enabled pulumi.BoolPtrInput `pulumi:"enabled"`
	// Selector to select which namespaces the Endpoints objects are discovered from.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (CoreDNSPrometheusMonitorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSPrometheusMonitor)(nil)).Elem()
}

func (i CoreDNSPrometheusMonitorArgs) ToCoreDNSPrometheusMonitorOutput() CoreDNSPrometheusMonitorOutput {
	return i.ToCoreDNSPrometheusMonitorOutputWithContext(context.Background())
}

func (i CoreDNSPrometheusMonitorArgs) ToCoreDNSPrometheusMonitorOutputWithContext(ctx context.Context) CoreDNSPrometheusMonitorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusMonitorOutput)
}

func (i CoreDNSPrometheusMonitorArgs) ToCoreDNSPrometheusMonitorPtrOutput() CoreDNSPrometheusMonitorPtrOutput {
	return i.ToCoreDNSPrometheusMonitorPtrOutputWithContext(context.Background())
}

func (i CoreDNSPrometheusMonitorArgs) ToCoreDNSPrometheusMonitorPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusMonitorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusMonitorOutput).ToCoreDNSPrometheusMonitorPtrOutputWithContext(ctx)
}

// CoreDNSPrometheusMonitorPtrInput is an input type that accepts CoreDNSPrometheusMonitorArgs, CoreDNSPrometheusMonitorPtr and CoreDNSPrometheusMonitorPtrOutput values.
// You can construct a concrete instance of `CoreDNSPrometheusMonitorPtrInput` via:
//
//          CoreDNSPrometheusMonitorArgs{...}
//
//  or:
//
//          nil
type CoreDNSPrometheusMonitorPtrInput interface {
	pulumi.Input

	ToCoreDNSPrometheusMonitorPtrOutput() CoreDNSPrometheusMonitorPtrOutput
	ToCoreDNSPrometheusMonitorPtrOutputWithContext(context.Context) CoreDNSPrometheusMonitorPtrOutput
}

type coreDNSPrometheusMonitorPtrType CoreDNSPrometheusMonitorArgs

func CoreDNSPrometheusMonitorPtr(v *CoreDNSPrometheusMonitorArgs) CoreDNSPrometheusMonitorPtrInput {
	return (*coreDNSPrometheusMonitorPtrType)(v)
}

func (*coreDNSPrometheusMonitorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSPrometheusMonitor)(nil)).Elem()
}

func (i *coreDNSPrometheusMonitorPtrType) ToCoreDNSPrometheusMonitorPtrOutput() CoreDNSPrometheusMonitorPtrOutput {
	return i.ToCoreDNSPrometheusMonitorPtrOutputWithContext(context.Background())
}

func (i *coreDNSPrometheusMonitorPtrType) ToCoreDNSPrometheusMonitorPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusMonitorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusMonitorPtrOutput)
}

type CoreDNSPrometheusMonitorOutput struct{ *pulumi.OutputState }

func (CoreDNSPrometheusMonitorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSPrometheusMonitor)(nil)).Elem()
}

func (o CoreDNSPrometheusMonitorOutput) ToCoreDNSPrometheusMonitorOutput() CoreDNSPrometheusMonitorOutput {
	return o
}

func (o CoreDNSPrometheusMonitorOutput) ToCoreDNSPrometheusMonitorOutputWithContext(ctx context.Context) CoreDNSPrometheusMonitorOutput {
	return o
}

func (o CoreDNSPrometheusMonitorOutput) ToCoreDNSPrometheusMonitorPtrOutput() CoreDNSPrometheusMonitorPtrOutput {
	return o.ToCoreDNSPrometheusMonitorPtrOutputWithContext(context.Background())
}

func (o CoreDNSPrometheusMonitorOutput) ToCoreDNSPrometheusMonitorPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusMonitorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSPrometheusMonitor) *CoreDNSPrometheusMonitor {
		return &v
	}).(CoreDNSPrometheusMonitorPtrOutput)
}

// Additional labels that can be used so ServiceMonitor will be discovered by Prometheus.
func (o CoreDNSPrometheusMonitorOutput) AdditionalLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreDNSPrometheusMonitor) map[string]string { return v.AdditionalLabels }).(pulumi.StringMapOutput)
}

// Set this to true to create ServiceMonitor for Prometheus operator.
func (o CoreDNSPrometheusMonitorOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSPrometheusMonitor) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// Selector to select which namespaces the Endpoints objects are discovered from.
func (o CoreDNSPrometheusMonitorOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSPrometheusMonitor) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type CoreDNSPrometheusMonitorPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSPrometheusMonitorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSPrometheusMonitor)(nil)).Elem()
}

func (o CoreDNSPrometheusMonitorPtrOutput) ToCoreDNSPrometheusMonitorPtrOutput() CoreDNSPrometheusMonitorPtrOutput {
	return o
}

func (o CoreDNSPrometheusMonitorPtrOutput) ToCoreDNSPrometheusMonitorPtrOutputWithContext(ctx context.Context) CoreDNSPrometheusMonitorPtrOutput {
	return o
}

func (o CoreDNSPrometheusMonitorPtrOutput) Elem() CoreDNSPrometheusMonitorOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusMonitor) CoreDNSPrometheusMonitor {
		if v != nil {
			return *v
		}
		var ret CoreDNSPrometheusMonitor
		return ret
	}).(CoreDNSPrometheusMonitorOutput)
}

// Additional labels that can be used so ServiceMonitor will be discovered by Prometheus.
func (o CoreDNSPrometheusMonitorPtrOutput) AdditionalLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusMonitor) map[string]string {
		if v == nil {
			return nil
		}
		return v.AdditionalLabels
	}).(pulumi.StringMapOutput)
}

// Set this to true to create ServiceMonitor for Prometheus operator.
func (o CoreDNSPrometheusMonitorPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusMonitor) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// Selector to select which namespaces the Endpoints objects are discovered from.
func (o CoreDNSPrometheusMonitorPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusMonitor) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

type CoreDNSPrometheusService struct {
	// Annotations to add to the metrics Service.
	Annotations map[string]string `pulumi:"annotations"`
	// Set this to true to create Service for Prometheus metrics.
	Enabled *bool `pulumi:"enabled"`
}

// CoreDNSPrometheusServiceInput is an input type that accepts CoreDNSPrometheusServiceArgs and CoreDNSPrometheusServiceOutput values.
// You can construct a concrete instance of `CoreDNSPrometheusServiceInput` via:
//
//          CoreDNSPrometheusServiceArgs{...}
type CoreDNSPrometheusServiceInput interface {
	pulumi.Input

	ToCoreDNSPrometheusServiceOutput() CoreDNSPrometheusServiceOutput
	ToCoreDNSPrometheusServiceOutputWithContext(context.Context) CoreDNSPrometheusServiceOutput
}

type CoreDNSPrometheusServiceArgs struct {
	// Annotations to add to the metrics Service.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Set this to true to create Service for Prometheus metrics.
	Enabled pulumi.BoolPtrInput `pulumi:"enabled"`
}

func (CoreDNSPrometheusServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSPrometheusService)(nil)).Elem()
}

func (i CoreDNSPrometheusServiceArgs) ToCoreDNSPrometheusServiceOutput() CoreDNSPrometheusServiceOutput {
	return i.ToCoreDNSPrometheusServiceOutputWithContext(context.Background())
}

func (i CoreDNSPrometheusServiceArgs) ToCoreDNSPrometheusServiceOutputWithContext(ctx context.Context) CoreDNSPrometheusServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusServiceOutput)
}

func (i CoreDNSPrometheusServiceArgs) ToCoreDNSPrometheusServicePtrOutput() CoreDNSPrometheusServicePtrOutput {
	return i.ToCoreDNSPrometheusServicePtrOutputWithContext(context.Background())
}

func (i CoreDNSPrometheusServiceArgs) ToCoreDNSPrometheusServicePtrOutputWithContext(ctx context.Context) CoreDNSPrometheusServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusServiceOutput).ToCoreDNSPrometheusServicePtrOutputWithContext(ctx)
}

// CoreDNSPrometheusServicePtrInput is an input type that accepts CoreDNSPrometheusServiceArgs, CoreDNSPrometheusServicePtr and CoreDNSPrometheusServicePtrOutput values.
// You can construct a concrete instance of `CoreDNSPrometheusServicePtrInput` via:
//
//          CoreDNSPrometheusServiceArgs{...}
//
//  or:
//
//          nil
type CoreDNSPrometheusServicePtrInput interface {
	pulumi.Input

	ToCoreDNSPrometheusServicePtrOutput() CoreDNSPrometheusServicePtrOutput
	ToCoreDNSPrometheusServicePtrOutputWithContext(context.Context) CoreDNSPrometheusServicePtrOutput
}

type coreDNSPrometheusServicePtrType CoreDNSPrometheusServiceArgs

func CoreDNSPrometheusServicePtr(v *CoreDNSPrometheusServiceArgs) CoreDNSPrometheusServicePtrInput {
	return (*coreDNSPrometheusServicePtrType)(v)
}

func (*coreDNSPrometheusServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSPrometheusService)(nil)).Elem()
}

func (i *coreDNSPrometheusServicePtrType) ToCoreDNSPrometheusServicePtrOutput() CoreDNSPrometheusServicePtrOutput {
	return i.ToCoreDNSPrometheusServicePtrOutputWithContext(context.Background())
}

func (i *coreDNSPrometheusServicePtrType) ToCoreDNSPrometheusServicePtrOutputWithContext(ctx context.Context) CoreDNSPrometheusServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSPrometheusServicePtrOutput)
}

type CoreDNSPrometheusServiceOutput struct{ *pulumi.OutputState }

func (CoreDNSPrometheusServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSPrometheusService)(nil)).Elem()
}

func (o CoreDNSPrometheusServiceOutput) ToCoreDNSPrometheusServiceOutput() CoreDNSPrometheusServiceOutput {
	return o
}

func (o CoreDNSPrometheusServiceOutput) ToCoreDNSPrometheusServiceOutputWithContext(ctx context.Context) CoreDNSPrometheusServiceOutput {
	return o
}

func (o CoreDNSPrometheusServiceOutput) ToCoreDNSPrometheusServicePtrOutput() CoreDNSPrometheusServicePtrOutput {
	return o.ToCoreDNSPrometheusServicePtrOutputWithContext(context.Background())
}

func (o CoreDNSPrometheusServiceOutput) ToCoreDNSPrometheusServicePtrOutputWithContext(ctx context.Context) CoreDNSPrometheusServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSPrometheusService) *CoreDNSPrometheusService {
		return &v
	}).(CoreDNSPrometheusServicePtrOutput)
}

// Annotations to add to the metrics Service.
func (o CoreDNSPrometheusServiceOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreDNSPrometheusService) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// Set this to true to create Service for Prometheus metrics.
func (o CoreDNSPrometheusServiceOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSPrometheusService) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

type CoreDNSPrometheusServicePtrOutput struct{ *pulumi.OutputState }

func (CoreDNSPrometheusServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSPrometheusService)(nil)).Elem()
}

func (o CoreDNSPrometheusServicePtrOutput) ToCoreDNSPrometheusServicePtrOutput() CoreDNSPrometheusServicePtrOutput {
	return o
}

func (o CoreDNSPrometheusServicePtrOutput) ToCoreDNSPrometheusServicePtrOutputWithContext(ctx context.Context) CoreDNSPrometheusServicePtrOutput {
	return o
}

func (o CoreDNSPrometheusServicePtrOutput) Elem() CoreDNSPrometheusServiceOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusService) CoreDNSPrometheusService {
		if v != nil {
			return *v
		}
		var ret CoreDNSPrometheusService
		return ret
	}).(CoreDNSPrometheusServiceOutput)
}

// Annotations to add to the metrics Service.
func (o CoreDNSPrometheusServicePtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusService) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Set this to true to create Service for Prometheus metrics.
func (o CoreDNSPrometheusServicePtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSPrometheusService) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

type CoreDNSRBAC struct {
	// If true, create & use RBAC resources
	Create *bool `pulumi:"create"`
	// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template.
	Name *string `pulumi:"name"`
	// If true, create and use PodSecurityPolicy
	PspEnable *bool `pulumi:"pspEnable"`
}

// CoreDNSRBACInput is an input type that accepts CoreDNSRBACArgs and CoreDNSRBACOutput values.
// You can construct a concrete instance of `CoreDNSRBACInput` via:
//
//          CoreDNSRBACArgs{...}
type CoreDNSRBACInput interface {
	pulumi.Input

	ToCoreDNSRBACOutput() CoreDNSRBACOutput
	ToCoreDNSRBACOutputWithContext(context.Context) CoreDNSRBACOutput
}

type CoreDNSRBACArgs struct {
	// If true, create & use RBAC resources
	Create pulumi.BoolPtrInput `pulumi:"create"`
	// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// If true, create and use PodSecurityPolicy
	PspEnable pulumi.BoolPtrInput `pulumi:"pspEnable"`
}

func (CoreDNSRBACArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSRBAC)(nil)).Elem()
}

func (i CoreDNSRBACArgs) ToCoreDNSRBACOutput() CoreDNSRBACOutput {
	return i.ToCoreDNSRBACOutputWithContext(context.Background())
}

func (i CoreDNSRBACArgs) ToCoreDNSRBACOutputWithContext(ctx context.Context) CoreDNSRBACOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSRBACOutput)
}

func (i CoreDNSRBACArgs) ToCoreDNSRBACPtrOutput() CoreDNSRBACPtrOutput {
	return i.ToCoreDNSRBACPtrOutputWithContext(context.Background())
}

func (i CoreDNSRBACArgs) ToCoreDNSRBACPtrOutputWithContext(ctx context.Context) CoreDNSRBACPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSRBACOutput).ToCoreDNSRBACPtrOutputWithContext(ctx)
}

// CoreDNSRBACPtrInput is an input type that accepts CoreDNSRBACArgs, CoreDNSRBACPtr and CoreDNSRBACPtrOutput values.
// You can construct a concrete instance of `CoreDNSRBACPtrInput` via:
//
//          CoreDNSRBACArgs{...}
//
//  or:
//
//          nil
type CoreDNSRBACPtrInput interface {
	pulumi.Input

	ToCoreDNSRBACPtrOutput() CoreDNSRBACPtrOutput
	ToCoreDNSRBACPtrOutputWithContext(context.Context) CoreDNSRBACPtrOutput
}

type coreDNSRBACPtrType CoreDNSRBACArgs

func CoreDNSRBACPtr(v *CoreDNSRBACArgs) CoreDNSRBACPtrInput {
	return (*coreDNSRBACPtrType)(v)
}

func (*coreDNSRBACPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSRBAC)(nil)).Elem()
}

func (i *coreDNSRBACPtrType) ToCoreDNSRBACPtrOutput() CoreDNSRBACPtrOutput {
	return i.ToCoreDNSRBACPtrOutputWithContext(context.Background())
}

func (i *coreDNSRBACPtrType) ToCoreDNSRBACPtrOutputWithContext(ctx context.Context) CoreDNSRBACPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSRBACPtrOutput)
}

type CoreDNSRBACOutput struct{ *pulumi.OutputState }

func (CoreDNSRBACOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSRBAC)(nil)).Elem()
}

func (o CoreDNSRBACOutput) ToCoreDNSRBACOutput() CoreDNSRBACOutput {
	return o
}

func (o CoreDNSRBACOutput) ToCoreDNSRBACOutputWithContext(ctx context.Context) CoreDNSRBACOutput {
	return o
}

func (o CoreDNSRBACOutput) ToCoreDNSRBACPtrOutput() CoreDNSRBACPtrOutput {
	return o.ToCoreDNSRBACPtrOutputWithContext(context.Background())
}

func (o CoreDNSRBACOutput) ToCoreDNSRBACPtrOutputWithContext(ctx context.Context) CoreDNSRBACPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSRBAC) *CoreDNSRBAC {
		return &v
	}).(CoreDNSRBACPtrOutput)
}

// If true, create & use RBAC resources
func (o CoreDNSRBACOutput) Create() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSRBAC) *bool { return v.Create }).(pulumi.BoolPtrOutput)
}

// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template.
func (o CoreDNSRBACOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSRBAC) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// If true, create and use PodSecurityPolicy
func (o CoreDNSRBACOutput) PspEnable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSRBAC) *bool { return v.PspEnable }).(pulumi.BoolPtrOutput)
}

type CoreDNSRBACPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSRBACPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSRBAC)(nil)).Elem()
}

func (o CoreDNSRBACPtrOutput) ToCoreDNSRBACPtrOutput() CoreDNSRBACPtrOutput {
	return o
}

func (o CoreDNSRBACPtrOutput) ToCoreDNSRBACPtrOutputWithContext(ctx context.Context) CoreDNSRBACPtrOutput {
	return o
}

func (o CoreDNSRBACPtrOutput) Elem() CoreDNSRBACOutput {
	return o.ApplyT(func(v *CoreDNSRBAC) CoreDNSRBAC {
		if v != nil {
			return *v
		}
		var ret CoreDNSRBAC
		return ret
	}).(CoreDNSRBACOutput)
}

// If true, create & use RBAC resources
func (o CoreDNSRBACPtrOutput) Create() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSRBAC) *bool {
		if v == nil {
			return nil
		}
		return v.Create
	}).(pulumi.BoolPtrOutput)
}

// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template.
func (o CoreDNSRBACPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSRBAC) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// If true, create and use PodSecurityPolicy
func (o CoreDNSRBACPtrOutput) PspEnable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSRBAC) *bool {
		if v == nil {
			return nil
		}
		return v.PspEnable
	}).(pulumi.BoolPtrOutput)
}

type CoreDNSServer struct {
	// the plugins to use for this server block.
	Plugins []CoreDNSServerPlugin `pulumi:"plugins"`
	// optional, defaults to "" (which equals 53 in CoreDNS).
	Port *int `pulumi:"port"`
	// the `zones` block can be left out entirely, defaults to "."
	Zones []CoreDNSServerZone `pulumi:"zones"`
}

// CoreDNSServerInput is an input type that accepts CoreDNSServerArgs and CoreDNSServerOutput values.
// You can construct a concrete instance of `CoreDNSServerInput` via:
//
//          CoreDNSServerArgs{...}
type CoreDNSServerInput interface {
	pulumi.Input

	ToCoreDNSServerOutput() CoreDNSServerOutput
	ToCoreDNSServerOutputWithContext(context.Context) CoreDNSServerOutput
}

type CoreDNSServerArgs struct {
	// the plugins to use for this server block.
	Plugins CoreDNSServerPluginArrayInput `pulumi:"plugins"`
	// optional, defaults to "" (which equals 53 in CoreDNS).
	Port pulumi.IntPtrInput `pulumi:"port"`
	// the `zones` block can be left out entirely, defaults to "."
	Zones CoreDNSServerZoneArrayInput `pulumi:"zones"`
}

func (CoreDNSServerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServer)(nil)).Elem()
}

func (i CoreDNSServerArgs) ToCoreDNSServerOutput() CoreDNSServerOutput {
	return i.ToCoreDNSServerOutputWithContext(context.Background())
}

func (i CoreDNSServerArgs) ToCoreDNSServerOutputWithContext(ctx context.Context) CoreDNSServerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServerOutput)
}

// CoreDNSServerArrayInput is an input type that accepts CoreDNSServerArray and CoreDNSServerArrayOutput values.
// You can construct a concrete instance of `CoreDNSServerArrayInput` via:
//
//          CoreDNSServerArray{ CoreDNSServerArgs{...} }
type CoreDNSServerArrayInput interface {
	pulumi.Input

	ToCoreDNSServerArrayOutput() CoreDNSServerArrayOutput
	ToCoreDNSServerArrayOutputWithContext(context.Context) CoreDNSServerArrayOutput
}

type CoreDNSServerArray []CoreDNSServerInput

func (CoreDNSServerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSServer)(nil)).Elem()
}

func (i CoreDNSServerArray) ToCoreDNSServerArrayOutput() CoreDNSServerArrayOutput {
	return i.ToCoreDNSServerArrayOutputWithContext(context.Background())
}

func (i CoreDNSServerArray) ToCoreDNSServerArrayOutputWithContext(ctx context.Context) CoreDNSServerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServerArrayOutput)
}

type CoreDNSServerOutput struct{ *pulumi.OutputState }

func (CoreDNSServerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServer)(nil)).Elem()
}

func (o CoreDNSServerOutput) ToCoreDNSServerOutput() CoreDNSServerOutput {
	return o
}

func (o CoreDNSServerOutput) ToCoreDNSServerOutputWithContext(ctx context.Context) CoreDNSServerOutput {
	return o
}

// the plugins to use for this server block.
func (o CoreDNSServerOutput) Plugins() CoreDNSServerPluginArrayOutput {
	return o.ApplyT(func(v CoreDNSServer) []CoreDNSServerPlugin { return v.Plugins }).(CoreDNSServerPluginArrayOutput)
}

// optional, defaults to "" (which equals 53 in CoreDNS).
func (o CoreDNSServerOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v CoreDNSServer) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// the `zones` block can be left out entirely, defaults to "."
func (o CoreDNSServerOutput) Zones() CoreDNSServerZoneArrayOutput {
	return o.ApplyT(func(v CoreDNSServer) []CoreDNSServerZone { return v.Zones }).(CoreDNSServerZoneArrayOutput)
}

type CoreDNSServerArrayOutput struct{ *pulumi.OutputState }

func (CoreDNSServerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSServer)(nil)).Elem()
}

func (o CoreDNSServerArrayOutput) ToCoreDNSServerArrayOutput() CoreDNSServerArrayOutput {
	return o
}

func (o CoreDNSServerArrayOutput) ToCoreDNSServerArrayOutputWithContext(ctx context.Context) CoreDNSServerArrayOutput {
	return o
}

func (o CoreDNSServerArrayOutput) Index(i pulumi.IntInput) CoreDNSServerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CoreDNSServer {
		return vs[0].([]CoreDNSServer)[vs[1].(int)]
	}).(CoreDNSServerOutput)
}

type CoreDNSServerPlugin struct {
	// if the plugin supports extra block style config, supply it here
	ConfigBlock *string `pulumi:"configBlock"`
	// name of plugin, if used multiple times ensure that the plugin supports it!
	Name *string `pulumi:"name"`
	// list of parameters after the plugin
	Parameters *string `pulumi:"parameters"`
}

// CoreDNSServerPluginInput is an input type that accepts CoreDNSServerPluginArgs and CoreDNSServerPluginOutput values.
// You can construct a concrete instance of `CoreDNSServerPluginInput` via:
//
//          CoreDNSServerPluginArgs{...}
type CoreDNSServerPluginInput interface {
	pulumi.Input

	ToCoreDNSServerPluginOutput() CoreDNSServerPluginOutput
	ToCoreDNSServerPluginOutputWithContext(context.Context) CoreDNSServerPluginOutput
}

type CoreDNSServerPluginArgs struct {
	// if the plugin supports extra block style config, supply it here
	ConfigBlock pulumi.StringPtrInput `pulumi:"configBlock"`
	// name of plugin, if used multiple times ensure that the plugin supports it!
	Name pulumi.StringPtrInput `pulumi:"name"`
	// list of parameters after the plugin
	Parameters pulumi.StringPtrInput `pulumi:"parameters"`
}

func (CoreDNSServerPluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServerPlugin)(nil)).Elem()
}

func (i CoreDNSServerPluginArgs) ToCoreDNSServerPluginOutput() CoreDNSServerPluginOutput {
	return i.ToCoreDNSServerPluginOutputWithContext(context.Background())
}

func (i CoreDNSServerPluginArgs) ToCoreDNSServerPluginOutputWithContext(ctx context.Context) CoreDNSServerPluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServerPluginOutput)
}

// CoreDNSServerPluginArrayInput is an input type that accepts CoreDNSServerPluginArray and CoreDNSServerPluginArrayOutput values.
// You can construct a concrete instance of `CoreDNSServerPluginArrayInput` via:
//
//          CoreDNSServerPluginArray{ CoreDNSServerPluginArgs{...} }
type CoreDNSServerPluginArrayInput interface {
	pulumi.Input

	ToCoreDNSServerPluginArrayOutput() CoreDNSServerPluginArrayOutput
	ToCoreDNSServerPluginArrayOutputWithContext(context.Context) CoreDNSServerPluginArrayOutput
}

type CoreDNSServerPluginArray []CoreDNSServerPluginInput

func (CoreDNSServerPluginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSServerPlugin)(nil)).Elem()
}

func (i CoreDNSServerPluginArray) ToCoreDNSServerPluginArrayOutput() CoreDNSServerPluginArrayOutput {
	return i.ToCoreDNSServerPluginArrayOutputWithContext(context.Background())
}

func (i CoreDNSServerPluginArray) ToCoreDNSServerPluginArrayOutputWithContext(ctx context.Context) CoreDNSServerPluginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServerPluginArrayOutput)
}

type CoreDNSServerPluginOutput struct{ *pulumi.OutputState }

func (CoreDNSServerPluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServerPlugin)(nil)).Elem()
}

func (o CoreDNSServerPluginOutput) ToCoreDNSServerPluginOutput() CoreDNSServerPluginOutput {
	return o
}

func (o CoreDNSServerPluginOutput) ToCoreDNSServerPluginOutputWithContext(ctx context.Context) CoreDNSServerPluginOutput {
	return o
}

// if the plugin supports extra block style config, supply it here
func (o CoreDNSServerPluginOutput) ConfigBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSServerPlugin) *string { return v.ConfigBlock }).(pulumi.StringPtrOutput)
}

// name of plugin, if used multiple times ensure that the plugin supports it!
func (o CoreDNSServerPluginOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSServerPlugin) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// list of parameters after the plugin
func (o CoreDNSServerPluginOutput) Parameters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSServerPlugin) *string { return v.Parameters }).(pulumi.StringPtrOutput)
}

type CoreDNSServerPluginArrayOutput struct{ *pulumi.OutputState }

func (CoreDNSServerPluginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSServerPlugin)(nil)).Elem()
}

func (o CoreDNSServerPluginArrayOutput) ToCoreDNSServerPluginArrayOutput() CoreDNSServerPluginArrayOutput {
	return o
}

func (o CoreDNSServerPluginArrayOutput) ToCoreDNSServerPluginArrayOutputWithContext(ctx context.Context) CoreDNSServerPluginArrayOutput {
	return o
}

func (o CoreDNSServerPluginArrayOutput) Index(i pulumi.IntInput) CoreDNSServerPluginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CoreDNSServerPlugin {
		return vs[0].([]CoreDNSServerPlugin)[vs[1].(int)]
	}).(CoreDNSServerPluginOutput)
}

type CoreDNSServerZone struct {
	// optional, defaults to "" (which equals "dns://" in CoreDNS)
	Scheme *string `pulumi:"scheme"`
	// set this parameter to optionally expose the port on tcp as well as udp for the DNS protocol. Note that this will not work if you are also exposing tls or grpc on the same server.
	Use_tcp *bool `pulumi:"use_tcp"`
	// optional, defaults to "."
	Zone *string `pulumi:"zone"`
}

// CoreDNSServerZoneInput is an input type that accepts CoreDNSServerZoneArgs and CoreDNSServerZoneOutput values.
// You can construct a concrete instance of `CoreDNSServerZoneInput` via:
//
//          CoreDNSServerZoneArgs{...}
type CoreDNSServerZoneInput interface {
	pulumi.Input

	ToCoreDNSServerZoneOutput() CoreDNSServerZoneOutput
	ToCoreDNSServerZoneOutputWithContext(context.Context) CoreDNSServerZoneOutput
}

type CoreDNSServerZoneArgs struct {
	// optional, defaults to "" (which equals "dns://" in CoreDNS)
	Scheme pulumi.StringPtrInput `pulumi:"scheme"`
	// set this parameter to optionally expose the port on tcp as well as udp for the DNS protocol. Note that this will not work if you are also exposing tls or grpc on the same server.
	Use_tcp pulumi.BoolPtrInput `pulumi:"use_tcp"`
	// optional, defaults to "."
	Zone pulumi.StringPtrInput `pulumi:"zone"`
}

func (CoreDNSServerZoneArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServerZone)(nil)).Elem()
}

func (i CoreDNSServerZoneArgs) ToCoreDNSServerZoneOutput() CoreDNSServerZoneOutput {
	return i.ToCoreDNSServerZoneOutputWithContext(context.Background())
}

func (i CoreDNSServerZoneArgs) ToCoreDNSServerZoneOutputWithContext(ctx context.Context) CoreDNSServerZoneOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServerZoneOutput)
}

// CoreDNSServerZoneArrayInput is an input type that accepts CoreDNSServerZoneArray and CoreDNSServerZoneArrayOutput values.
// You can construct a concrete instance of `CoreDNSServerZoneArrayInput` via:
//
//          CoreDNSServerZoneArray{ CoreDNSServerZoneArgs{...} }
type CoreDNSServerZoneArrayInput interface {
	pulumi.Input

	ToCoreDNSServerZoneArrayOutput() CoreDNSServerZoneArrayOutput
	ToCoreDNSServerZoneArrayOutputWithContext(context.Context) CoreDNSServerZoneArrayOutput
}

type CoreDNSServerZoneArray []CoreDNSServerZoneInput

func (CoreDNSServerZoneArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSServerZone)(nil)).Elem()
}

func (i CoreDNSServerZoneArray) ToCoreDNSServerZoneArrayOutput() CoreDNSServerZoneArrayOutput {
	return i.ToCoreDNSServerZoneArrayOutputWithContext(context.Background())
}

func (i CoreDNSServerZoneArray) ToCoreDNSServerZoneArrayOutputWithContext(ctx context.Context) CoreDNSServerZoneArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServerZoneArrayOutput)
}

type CoreDNSServerZoneOutput struct{ *pulumi.OutputState }

func (CoreDNSServerZoneOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServerZone)(nil)).Elem()
}

func (o CoreDNSServerZoneOutput) ToCoreDNSServerZoneOutput() CoreDNSServerZoneOutput {
	return o
}

func (o CoreDNSServerZoneOutput) ToCoreDNSServerZoneOutputWithContext(ctx context.Context) CoreDNSServerZoneOutput {
	return o
}

// optional, defaults to "" (which equals "dns://" in CoreDNS)
func (o CoreDNSServerZoneOutput) Scheme() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSServerZone) *string { return v.Scheme }).(pulumi.StringPtrOutput)
}

// set this parameter to optionally expose the port on tcp as well as udp for the DNS protocol. Note that this will not work if you are also exposing tls or grpc on the same server.
func (o CoreDNSServerZoneOutput) Use_tcp() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSServerZone) *bool { return v.Use_tcp }).(pulumi.BoolPtrOutput)
}

// optional, defaults to "."
func (o CoreDNSServerZoneOutput) Zone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSServerZone) *string { return v.Zone }).(pulumi.StringPtrOutput)
}

type CoreDNSServerZoneArrayOutput struct{ *pulumi.OutputState }

func (CoreDNSServerZoneArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSServerZone)(nil)).Elem()
}

func (o CoreDNSServerZoneArrayOutput) ToCoreDNSServerZoneArrayOutput() CoreDNSServerZoneArrayOutput {
	return o
}

func (o CoreDNSServerZoneArrayOutput) ToCoreDNSServerZoneArrayOutputWithContext(ctx context.Context) CoreDNSServerZoneArrayOutput {
	return o
}

func (o CoreDNSServerZoneArrayOutput) Index(i pulumi.IntInput) CoreDNSServerZoneOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CoreDNSServerZone {
		return vs[0].([]CoreDNSServerZone)[vs[1].(int)]
	}).(CoreDNSServerZoneOutput)
}

type CoreDNSService struct {
	// Annotations to add to service.
	Annotations map[string]string `pulumi:"annotations"`
	// IP address to assign to service.
	ClusterIP *string `pulumi:"clusterIP"`
	// External IP addresses.
	ExternalIPs []string `pulumi:"externalIPs"`
	// Enable client source IP preservation.
	ExternalTrafficPolicy *string `pulumi:"externalTrafficPolicy"`
	// IP address to assign to load balancer (if supported).
	LoadBalancerIP *string `pulumi:"loadBalancerIP"`
	// The name of the Service. If not set, a name is generated using the fullname template.
	Name *string `pulumi:"name"`
}

// CoreDNSServiceInput is an input type that accepts CoreDNSServiceArgs and CoreDNSServiceOutput values.
// You can construct a concrete instance of `CoreDNSServiceInput` via:
//
//          CoreDNSServiceArgs{...}
type CoreDNSServiceInput interface {
	pulumi.Input

	ToCoreDNSServiceOutput() CoreDNSServiceOutput
	ToCoreDNSServiceOutputWithContext(context.Context) CoreDNSServiceOutput
}

type CoreDNSServiceArgs struct {
	// Annotations to add to service.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// IP address to assign to service.
	ClusterIP pulumi.StringPtrInput `pulumi:"clusterIP"`
	// External IP addresses.
	ExternalIPs pulumi.StringArrayInput `pulumi:"externalIPs"`
	// Enable client source IP preservation.
	ExternalTrafficPolicy pulumi.StringPtrInput `pulumi:"externalTrafficPolicy"`
	// IP address to assign to load balancer (if supported).
	LoadBalancerIP pulumi.StringPtrInput `pulumi:"loadBalancerIP"`
	// The name of the Service. If not set, a name is generated using the fullname template.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CoreDNSServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSService)(nil)).Elem()
}

func (i CoreDNSServiceArgs) ToCoreDNSServiceOutput() CoreDNSServiceOutput {
	return i.ToCoreDNSServiceOutputWithContext(context.Background())
}

func (i CoreDNSServiceArgs) ToCoreDNSServiceOutputWithContext(ctx context.Context) CoreDNSServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServiceOutput)
}

func (i CoreDNSServiceArgs) ToCoreDNSServicePtrOutput() CoreDNSServicePtrOutput {
	return i.ToCoreDNSServicePtrOutputWithContext(context.Background())
}

func (i CoreDNSServiceArgs) ToCoreDNSServicePtrOutputWithContext(ctx context.Context) CoreDNSServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServiceOutput).ToCoreDNSServicePtrOutputWithContext(ctx)
}

// CoreDNSServicePtrInput is an input type that accepts CoreDNSServiceArgs, CoreDNSServicePtr and CoreDNSServicePtrOutput values.
// You can construct a concrete instance of `CoreDNSServicePtrInput` via:
//
//          CoreDNSServiceArgs{...}
//
//  or:
//
//          nil
type CoreDNSServicePtrInput interface {
	pulumi.Input

	ToCoreDNSServicePtrOutput() CoreDNSServicePtrOutput
	ToCoreDNSServicePtrOutputWithContext(context.Context) CoreDNSServicePtrOutput
}

type coreDNSServicePtrType CoreDNSServiceArgs

func CoreDNSServicePtr(v *CoreDNSServiceArgs) CoreDNSServicePtrInput {
	return (*coreDNSServicePtrType)(v)
}

func (*coreDNSServicePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSService)(nil)).Elem()
}

func (i *coreDNSServicePtrType) ToCoreDNSServicePtrOutput() CoreDNSServicePtrOutput {
	return i.ToCoreDNSServicePtrOutputWithContext(context.Background())
}

func (i *coreDNSServicePtrType) ToCoreDNSServicePtrOutputWithContext(ctx context.Context) CoreDNSServicePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServicePtrOutput)
}

type CoreDNSServiceOutput struct{ *pulumi.OutputState }

func (CoreDNSServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSService)(nil)).Elem()
}

func (o CoreDNSServiceOutput) ToCoreDNSServiceOutput() CoreDNSServiceOutput {
	return o
}

func (o CoreDNSServiceOutput) ToCoreDNSServiceOutputWithContext(ctx context.Context) CoreDNSServiceOutput {
	return o
}

func (o CoreDNSServiceOutput) ToCoreDNSServicePtrOutput() CoreDNSServicePtrOutput {
	return o.ToCoreDNSServicePtrOutputWithContext(context.Background())
}

func (o CoreDNSServiceOutput) ToCoreDNSServicePtrOutputWithContext(ctx context.Context) CoreDNSServicePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSService) *CoreDNSService {
		return &v
	}).(CoreDNSServicePtrOutput)
}

// Annotations to add to service.
func (o CoreDNSServiceOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreDNSService) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// IP address to assign to service.
func (o CoreDNSServiceOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSService) *string { return v.ClusterIP }).(pulumi.StringPtrOutput)
}

// External IP addresses.
func (o CoreDNSServiceOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CoreDNSService) []string { return v.ExternalIPs }).(pulumi.StringArrayOutput)
}

// Enable client source IP preservation.
func (o CoreDNSServiceOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSService) *string { return v.ExternalTrafficPolicy }).(pulumi.StringPtrOutput)
}

// IP address to assign to load balancer (if supported).
func (o CoreDNSServiceOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSService) *string { return v.LoadBalancerIP }).(pulumi.StringPtrOutput)
}

// The name of the Service. If not set, a name is generated using the fullname template.
func (o CoreDNSServiceOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSService) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CoreDNSServicePtrOutput struct{ *pulumi.OutputState }

func (CoreDNSServicePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSService)(nil)).Elem()
}

func (o CoreDNSServicePtrOutput) ToCoreDNSServicePtrOutput() CoreDNSServicePtrOutput {
	return o
}

func (o CoreDNSServicePtrOutput) ToCoreDNSServicePtrOutputWithContext(ctx context.Context) CoreDNSServicePtrOutput {
	return o
}

func (o CoreDNSServicePtrOutput) Elem() CoreDNSServiceOutput {
	return o.ApplyT(func(v *CoreDNSService) CoreDNSService {
		if v != nil {
			return *v
		}
		var ret CoreDNSService
		return ret
	}).(CoreDNSServiceOutput)
}

// Annotations to add to service.
func (o CoreDNSServicePtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CoreDNSService) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// IP address to assign to service.
func (o CoreDNSServicePtrOutput) ClusterIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSService) *string {
		if v == nil {
			return nil
		}
		return v.ClusterIP
	}).(pulumi.StringPtrOutput)
}

// External IP addresses.
func (o CoreDNSServicePtrOutput) ExternalIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CoreDNSService) []string {
		if v == nil {
			return nil
		}
		return v.ExternalIPs
	}).(pulumi.StringArrayOutput)
}

// Enable client source IP preservation.
func (o CoreDNSServicePtrOutput) ExternalTrafficPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSService) *string {
		if v == nil {
			return nil
		}
		return v.ExternalTrafficPolicy
	}).(pulumi.StringPtrOutput)
}

// IP address to assign to load balancer (if supported).
func (o CoreDNSServicePtrOutput) LoadBalancerIP() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSService) *string {
		if v == nil {
			return nil
		}
		return v.LoadBalancerIP
	}).(pulumi.StringPtrOutput)
}

// The name of the Service. If not set, a name is generated using the fullname template.
func (o CoreDNSServicePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSService) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type CoreDNSServiceAccount struct {
	Annotations map[string]string `pulumi:"annotations"`
	// If true, create & use serviceAccount.
	Create *bool `pulumi:"create"`
	// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template
	Name *string `pulumi:"name"`
}

// CoreDNSServiceAccountInput is an input type that accepts CoreDNSServiceAccountArgs and CoreDNSServiceAccountOutput values.
// You can construct a concrete instance of `CoreDNSServiceAccountInput` via:
//
//          CoreDNSServiceAccountArgs{...}
type CoreDNSServiceAccountInput interface {
	pulumi.Input

	ToCoreDNSServiceAccountOutput() CoreDNSServiceAccountOutput
	ToCoreDNSServiceAccountOutputWithContext(context.Context) CoreDNSServiceAccountOutput
}

type CoreDNSServiceAccountArgs struct {
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// If true, create & use serviceAccount.
	Create pulumi.BoolPtrInput `pulumi:"create"`
	// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (CoreDNSServiceAccountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServiceAccount)(nil)).Elem()
}

func (i CoreDNSServiceAccountArgs) ToCoreDNSServiceAccountOutput() CoreDNSServiceAccountOutput {
	return i.ToCoreDNSServiceAccountOutputWithContext(context.Background())
}

func (i CoreDNSServiceAccountArgs) ToCoreDNSServiceAccountOutputWithContext(ctx context.Context) CoreDNSServiceAccountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServiceAccountOutput)
}

func (i CoreDNSServiceAccountArgs) ToCoreDNSServiceAccountPtrOutput() CoreDNSServiceAccountPtrOutput {
	return i.ToCoreDNSServiceAccountPtrOutputWithContext(context.Background())
}

func (i CoreDNSServiceAccountArgs) ToCoreDNSServiceAccountPtrOutputWithContext(ctx context.Context) CoreDNSServiceAccountPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServiceAccountOutput).ToCoreDNSServiceAccountPtrOutputWithContext(ctx)
}

// CoreDNSServiceAccountPtrInput is an input type that accepts CoreDNSServiceAccountArgs, CoreDNSServiceAccountPtr and CoreDNSServiceAccountPtrOutput values.
// You can construct a concrete instance of `CoreDNSServiceAccountPtrInput` via:
//
//          CoreDNSServiceAccountArgs{...}
//
//  or:
//
//          nil
type CoreDNSServiceAccountPtrInput interface {
	pulumi.Input

	ToCoreDNSServiceAccountPtrOutput() CoreDNSServiceAccountPtrOutput
	ToCoreDNSServiceAccountPtrOutputWithContext(context.Context) CoreDNSServiceAccountPtrOutput
}

type coreDNSServiceAccountPtrType CoreDNSServiceAccountArgs

func CoreDNSServiceAccountPtr(v *CoreDNSServiceAccountArgs) CoreDNSServiceAccountPtrInput {
	return (*coreDNSServiceAccountPtrType)(v)
}

func (*coreDNSServiceAccountPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSServiceAccount)(nil)).Elem()
}

func (i *coreDNSServiceAccountPtrType) ToCoreDNSServiceAccountPtrOutput() CoreDNSServiceAccountPtrOutput {
	return i.ToCoreDNSServiceAccountPtrOutputWithContext(context.Background())
}

func (i *coreDNSServiceAccountPtrType) ToCoreDNSServiceAccountPtrOutputWithContext(ctx context.Context) CoreDNSServiceAccountPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSServiceAccountPtrOutput)
}

type CoreDNSServiceAccountOutput struct{ *pulumi.OutputState }

func (CoreDNSServiceAccountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSServiceAccount)(nil)).Elem()
}

func (o CoreDNSServiceAccountOutput) ToCoreDNSServiceAccountOutput() CoreDNSServiceAccountOutput {
	return o
}

func (o CoreDNSServiceAccountOutput) ToCoreDNSServiceAccountOutputWithContext(ctx context.Context) CoreDNSServiceAccountOutput {
	return o
}

func (o CoreDNSServiceAccountOutput) ToCoreDNSServiceAccountPtrOutput() CoreDNSServiceAccountPtrOutput {
	return o.ToCoreDNSServiceAccountPtrOutputWithContext(context.Background())
}

func (o CoreDNSServiceAccountOutput) ToCoreDNSServiceAccountPtrOutputWithContext(ctx context.Context) CoreDNSServiceAccountPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v CoreDNSServiceAccount) *CoreDNSServiceAccount {
		return &v
	}).(CoreDNSServiceAccountPtrOutput)
}

func (o CoreDNSServiceAccountOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v CoreDNSServiceAccount) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// If true, create & use serviceAccount.
func (o CoreDNSServiceAccountOutput) Create() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v CoreDNSServiceAccount) *bool { return v.Create }).(pulumi.BoolPtrOutput)
}

// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template
func (o CoreDNSServiceAccountOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSServiceAccount) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type CoreDNSServiceAccountPtrOutput struct{ *pulumi.OutputState }

func (CoreDNSServiceAccountPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreDNSServiceAccount)(nil)).Elem()
}

func (o CoreDNSServiceAccountPtrOutput) ToCoreDNSServiceAccountPtrOutput() CoreDNSServiceAccountPtrOutput {
	return o
}

func (o CoreDNSServiceAccountPtrOutput) ToCoreDNSServiceAccountPtrOutputWithContext(ctx context.Context) CoreDNSServiceAccountPtrOutput {
	return o
}

func (o CoreDNSServiceAccountPtrOutput) Elem() CoreDNSServiceAccountOutput {
	return o.ApplyT(func(v *CoreDNSServiceAccount) CoreDNSServiceAccount {
		if v != nil {
			return *v
		}
		var ret CoreDNSServiceAccount
		return ret
	}).(CoreDNSServiceAccountOutput)
}

func (o CoreDNSServiceAccountPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CoreDNSServiceAccount) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// If true, create & use serviceAccount.
func (o CoreDNSServiceAccountPtrOutput) Create() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CoreDNSServiceAccount) *bool {
		if v == nil {
			return nil
		}
		return v.Create
	}).(pulumi.BoolPtrOutput)
}

// The name of the ServiceAccount to use. If not set and create is true, a name is generated using the fullname template
func (o CoreDNSServiceAccountPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CoreDNSServiceAccount) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type CoreDNSZoneFile struct {
	Contents *string `pulumi:"contents"`
	Domain   *string `pulumi:"domain"`
	String   *string `pulumi:"string"`
}

// CoreDNSZoneFileInput is an input type that accepts CoreDNSZoneFileArgs and CoreDNSZoneFileOutput values.
// You can construct a concrete instance of `CoreDNSZoneFileInput` via:
//
//          CoreDNSZoneFileArgs{...}
type CoreDNSZoneFileInput interface {
	pulumi.Input

	ToCoreDNSZoneFileOutput() CoreDNSZoneFileOutput
	ToCoreDNSZoneFileOutputWithContext(context.Context) CoreDNSZoneFileOutput
}

type CoreDNSZoneFileArgs struct {
	Contents pulumi.StringPtrInput `pulumi:"contents"`
	Domain   pulumi.StringPtrInput `pulumi:"domain"`
	String   pulumi.StringPtrInput `pulumi:"string"`
}

func (CoreDNSZoneFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSZoneFile)(nil)).Elem()
}

func (i CoreDNSZoneFileArgs) ToCoreDNSZoneFileOutput() CoreDNSZoneFileOutput {
	return i.ToCoreDNSZoneFileOutputWithContext(context.Background())
}

func (i CoreDNSZoneFileArgs) ToCoreDNSZoneFileOutputWithContext(ctx context.Context) CoreDNSZoneFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSZoneFileOutput)
}

// CoreDNSZoneFileArrayInput is an input type that accepts CoreDNSZoneFileArray and CoreDNSZoneFileArrayOutput values.
// You can construct a concrete instance of `CoreDNSZoneFileArrayInput` via:
//
//          CoreDNSZoneFileArray{ CoreDNSZoneFileArgs{...} }
type CoreDNSZoneFileArrayInput interface {
	pulumi.Input

	ToCoreDNSZoneFileArrayOutput() CoreDNSZoneFileArrayOutput
	ToCoreDNSZoneFileArrayOutputWithContext(context.Context) CoreDNSZoneFileArrayOutput
}

type CoreDNSZoneFileArray []CoreDNSZoneFileInput

func (CoreDNSZoneFileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSZoneFile)(nil)).Elem()
}

func (i CoreDNSZoneFileArray) ToCoreDNSZoneFileArrayOutput() CoreDNSZoneFileArrayOutput {
	return i.ToCoreDNSZoneFileArrayOutputWithContext(context.Background())
}

func (i CoreDNSZoneFileArray) ToCoreDNSZoneFileArrayOutputWithContext(ctx context.Context) CoreDNSZoneFileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreDNSZoneFileArrayOutput)
}

type CoreDNSZoneFileOutput struct{ *pulumi.OutputState }

func (CoreDNSZoneFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreDNSZoneFile)(nil)).Elem()
}

func (o CoreDNSZoneFileOutput) ToCoreDNSZoneFileOutput() CoreDNSZoneFileOutput {
	return o
}

func (o CoreDNSZoneFileOutput) ToCoreDNSZoneFileOutputWithContext(ctx context.Context) CoreDNSZoneFileOutput {
	return o
}

func (o CoreDNSZoneFileOutput) Contents() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSZoneFile) *string { return v.Contents }).(pulumi.StringPtrOutput)
}

func (o CoreDNSZoneFileOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSZoneFile) *string { return v.Domain }).(pulumi.StringPtrOutput)
}

func (o CoreDNSZoneFileOutput) String() pulumi.StringPtrOutput {
	return o.ApplyT(func(v CoreDNSZoneFile) *string { return v.String }).(pulumi.StringPtrOutput)
}

type CoreDNSZoneFileArrayOutput struct{ *pulumi.OutputState }

func (CoreDNSZoneFileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreDNSZoneFile)(nil)).Elem()
}

func (o CoreDNSZoneFileArrayOutput) ToCoreDNSZoneFileArrayOutput() CoreDNSZoneFileArrayOutput {
	return o
}

func (o CoreDNSZoneFileArrayOutput) ToCoreDNSZoneFileArrayOutputWithContext(ctx context.Context) CoreDNSZoneFileArrayOutput {
	return o
}

func (o CoreDNSZoneFileArrayOutput) Index(i pulumi.IntInput) CoreDNSZoneFileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CoreDNSZoneFile {
		return vs[0].([]CoreDNSZoneFile)[vs[1].(int)]
	}).(CoreDNSZoneFileOutput)
}

// A Release is an instance of a chart running in a Kubernetes cluster.
// A Chart is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster.
// Note - Helm Release is currently in BETA and may change. Use in production environment is discouraged.
type Release struct {
	// If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
	Atomic *bool `pulumi:"atomic"`
	// Chart name to be installed. A path may be used.
	Chart *string `pulumi:"chart"`
	// Allow deletion of new resources created in this upgrade when upgrade fails.
	CleanupOnFail *bool `pulumi:"cleanupOnFail"`
	// Create the namespace if it does not exist.
	CreateNamespace *bool `pulumi:"createNamespace"`
	// Run helm dependency update before installing the chart.
	DependencyUpdate *bool `pulumi:"dependencyUpdate"`
	// Add a custom description
	Description *string `pulumi:"description"`
	// Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
	Devel *bool `pulumi:"devel"`
	// Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
	DisableCRDHooks *bool `pulumi:"disableCRDHooks"`
	// If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
	DisableOpenapiValidation *bool `pulumi:"disableOpenapiValidation"`
	// Prevent hooks from running.
	DisableWebhooks *bool `pulumi:"disableWebhooks"`
	// Force resource update through delete/recreate if needed.
	ForceUpdate *bool `pulumi:"forceUpdate"`
	// Location of public keys used for verification. Used only if `verify` is true
	Keyring *string `pulumi:"keyring"`
	// Run helm lint when planning.
	Lint *bool `pulumi:"lint"`
	// The rendered manifests as JSON. Not yet supported.
	Manifest map[string]interface{} `pulumi:"manifest"`
	// Limit the maximum number of revisions saved per release. Use 0 for no limit.
	MaxHistory *int `pulumi:"maxHistory"`
	// Release name.
	Name *string `pulumi:"name"`
	// Namespace to install the release into.
	Namespace *string `pulumi:"namespace"`
	// Postrender command to run.
	Postrender *string `pulumi:"postrender"`
	// Perform pods restart during upgrade/rollback.
	RecreatePods *bool `pulumi:"recreatePods"`
	// If set, render subchart notes along with the parent.
	RenderSubchartNotes *bool `pulumi:"renderSubchartNotes"`
	// Re-use the given name, even if that name is already used. This is unsafe in production
	Replace *bool `pulumi:"replace"`
	// Specification defining the Helm chart repository to use.
	RepositoryOpts *RepositoryOpts `pulumi:"repositoryOpts"`
	// When upgrading, reset the values to the ones built into the chart.
	ResetValues *bool `pulumi:"resetValues"`
	// Names of resources created by the release grouped by "kind/version".
	ResourceNames map[string][]string `pulumi:"resourceNames"`
	// When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
	ReuseValues *bool `pulumi:"reuseValues"`
	// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
	SkipAwait *bool `pulumi:"skipAwait"`
	// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
	SkipCrds *bool `pulumi:"skipCrds"`
	// Time in seconds to wait for any individual kubernetes operation.
	Timeout *int `pulumi:"timeout"`
	// List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
	ValueYamlFiles []pulumi.AssetOrArchive `pulumi:"valueYamlFiles"`
	// Custom values set for the release.
	Values map[string]interface{} `pulumi:"values"`
	// Verify the package before installing it.
	Verify *bool `pulumi:"verify"`
	// Specify the exact chart version to install. If this is not specified, the latest version is installed.
	Version *string `pulumi:"version"`
	// Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
	WaitForJobs *bool `pulumi:"waitForJobs"`
}

// ReleaseInput is an input type that accepts ReleaseArgs and ReleaseOutput values.
// You can construct a concrete instance of `ReleaseInput` via:
//
//          ReleaseArgs{...}
type ReleaseInput interface {
	pulumi.Input

	ToReleaseOutput() ReleaseOutput
	ToReleaseOutputWithContext(context.Context) ReleaseOutput
}

// A Release is an instance of a chart running in a Kubernetes cluster.
// A Chart is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster.
// Note - Helm Release is currently in BETA and may change. Use in production environment is discouraged.
type ReleaseArgs struct {
	// If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
	Atomic pulumi.BoolPtrInput `pulumi:"atomic"`
	// Chart name to be installed. A path may be used.
	Chart pulumi.StringPtrInput `pulumi:"chart"`
	// Allow deletion of new resources created in this upgrade when upgrade fails.
	CleanupOnFail pulumi.BoolPtrInput `pulumi:"cleanupOnFail"`
	// Create the namespace if it does not exist.
	CreateNamespace pulumi.BoolPtrInput `pulumi:"createNamespace"`
	// Run helm dependency update before installing the chart.
	DependencyUpdate pulumi.BoolPtrInput `pulumi:"dependencyUpdate"`
	// Add a custom description
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
	Devel pulumi.BoolPtrInput `pulumi:"devel"`
	// Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
	DisableCRDHooks pulumi.BoolPtrInput `pulumi:"disableCRDHooks"`
	// If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
	DisableOpenapiValidation pulumi.BoolPtrInput `pulumi:"disableOpenapiValidation"`
	// Prevent hooks from running.
	DisableWebhooks pulumi.BoolPtrInput `pulumi:"disableWebhooks"`
	// Force resource update through delete/recreate if needed.
	ForceUpdate pulumi.BoolPtrInput `pulumi:"forceUpdate"`
	// Location of public keys used for verification. Used only if `verify` is true
	Keyring pulumi.StringPtrInput `pulumi:"keyring"`
	// Run helm lint when planning.
	Lint pulumi.BoolPtrInput `pulumi:"lint"`
	// The rendered manifests as JSON. Not yet supported.
	Manifest pulumi.MapInput `pulumi:"manifest"`
	// Limit the maximum number of revisions saved per release. Use 0 for no limit.
	MaxHistory pulumi.IntPtrInput `pulumi:"maxHistory"`
	// Release name.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace to install the release into.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Postrender command to run.
	Postrender pulumi.StringPtrInput `pulumi:"postrender"`
	// Perform pods restart during upgrade/rollback.
	RecreatePods pulumi.BoolPtrInput `pulumi:"recreatePods"`
	// If set, render subchart notes along with the parent.
	RenderSubchartNotes pulumi.BoolPtrInput `pulumi:"renderSubchartNotes"`
	// Re-use the given name, even if that name is already used. This is unsafe in production
	Replace pulumi.BoolPtrInput `pulumi:"replace"`
	// Specification defining the Helm chart repository to use.
	RepositoryOpts RepositoryOptsPtrInput `pulumi:"repositoryOpts"`
	// When upgrading, reset the values to the ones built into the chart.
	ResetValues pulumi.BoolPtrInput `pulumi:"resetValues"`
	// Names of resources created by the release grouped by "kind/version".
	ResourceNames pulumi.StringArrayMapInput `pulumi:"resourceNames"`
	// When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
	ReuseValues pulumi.BoolPtrInput `pulumi:"reuseValues"`
	// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
	SkipAwait pulumi.BoolPtrInput `pulumi:"skipAwait"`
	// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
	SkipCrds pulumi.BoolPtrInput `pulumi:"skipCrds"`
	// Time in seconds to wait for any individual kubernetes operation.
	Timeout pulumi.IntPtrInput `pulumi:"timeout"`
	// List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
	ValueYamlFiles pulumi.AssetOrArchiveArrayInput `pulumi:"valueYamlFiles"`
	// Custom values set for the release.
	Values pulumi.MapInput `pulumi:"values"`
	// Verify the package before installing it.
	Verify pulumi.BoolPtrInput `pulumi:"verify"`
	// Specify the exact chart version to install. If this is not specified, the latest version is installed.
	Version pulumi.StringPtrInput `pulumi:"version"`
	// Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
	WaitForJobs pulumi.BoolPtrInput `pulumi:"waitForJobs"`
}

func (ReleaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Release)(nil)).Elem()
}

func (i ReleaseArgs) ToReleaseOutput() ReleaseOutput {
	return i.ToReleaseOutputWithContext(context.Background())
}

func (i ReleaseArgs) ToReleaseOutputWithContext(ctx context.Context) ReleaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseOutput)
}

func (i ReleaseArgs) ToReleasePtrOutput() ReleasePtrOutput {
	return i.ToReleasePtrOutputWithContext(context.Background())
}

func (i ReleaseArgs) ToReleasePtrOutputWithContext(ctx context.Context) ReleasePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseOutput).ToReleasePtrOutputWithContext(ctx)
}

// ReleasePtrInput is an input type that accepts ReleaseArgs, ReleasePtr and ReleasePtrOutput values.
// You can construct a concrete instance of `ReleasePtrInput` via:
//
//          ReleaseArgs{...}
//
//  or:
//
//          nil
type ReleasePtrInput interface {
	pulumi.Input

	ToReleasePtrOutput() ReleasePtrOutput
	ToReleasePtrOutputWithContext(context.Context) ReleasePtrOutput
}

type releasePtrType ReleaseArgs

func ReleasePtr(v *ReleaseArgs) ReleasePtrInput {
	return (*releasePtrType)(v)
}

func (*releasePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Release)(nil)).Elem()
}

func (i *releasePtrType) ToReleasePtrOutput() ReleasePtrOutput {
	return i.ToReleasePtrOutputWithContext(context.Background())
}

func (i *releasePtrType) ToReleasePtrOutputWithContext(ctx context.Context) ReleasePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleasePtrOutput)
}

// A Release is an instance of a chart running in a Kubernetes cluster.
// A Chart is a Helm package. It contains all of the resource definitions necessary to run an application, tool, or service inside of a Kubernetes cluster.
// Note - Helm Release is currently in BETA and may change. Use in production environment is discouraged.
type ReleaseOutput struct{ *pulumi.OutputState }

func (ReleaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Release)(nil)).Elem()
}

func (o ReleaseOutput) ToReleaseOutput() ReleaseOutput {
	return o
}

func (o ReleaseOutput) ToReleaseOutputWithContext(ctx context.Context) ReleaseOutput {
	return o
}

func (o ReleaseOutput) ToReleasePtrOutput() ReleasePtrOutput {
	return o.ToReleasePtrOutputWithContext(context.Background())
}

func (o ReleaseOutput) ToReleasePtrOutputWithContext(ctx context.Context) ReleasePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Release) *Release {
		return &v
	}).(ReleasePtrOutput)
}

// If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
func (o ReleaseOutput) Atomic() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.Atomic }).(pulumi.BoolPtrOutput)
}

// Chart name to be installed. A path may be used.
func (o ReleaseOutput) Chart() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Chart }).(pulumi.StringPtrOutput)
}

// Allow deletion of new resources created in this upgrade when upgrade fails.
func (o ReleaseOutput) CleanupOnFail() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.CleanupOnFail }).(pulumi.BoolPtrOutput)
}

// Create the namespace if it does not exist.
func (o ReleaseOutput) CreateNamespace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.CreateNamespace }).(pulumi.BoolPtrOutput)
}

// Run helm dependency update before installing the chart.
func (o ReleaseOutput) DependencyUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.DependencyUpdate }).(pulumi.BoolPtrOutput)
}

// Add a custom description
func (o ReleaseOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
func (o ReleaseOutput) Devel() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.Devel }).(pulumi.BoolPtrOutput)
}

// Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
func (o ReleaseOutput) DisableCRDHooks() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.DisableCRDHooks }).(pulumi.BoolPtrOutput)
}

// If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
func (o ReleaseOutput) DisableOpenapiValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.DisableOpenapiValidation }).(pulumi.BoolPtrOutput)
}

// Prevent hooks from running.
func (o ReleaseOutput) DisableWebhooks() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.DisableWebhooks }).(pulumi.BoolPtrOutput)
}

// Force resource update through delete/recreate if needed.
func (o ReleaseOutput) ForceUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.ForceUpdate }).(pulumi.BoolPtrOutput)
}

// Location of public keys used for verification. Used only if `verify` is true
func (o ReleaseOutput) Keyring() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Keyring }).(pulumi.StringPtrOutput)
}

// Run helm lint when planning.
func (o ReleaseOutput) Lint() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.Lint }).(pulumi.BoolPtrOutput)
}

// The rendered manifests as JSON. Not yet supported.
func (o ReleaseOutput) Manifest() pulumi.MapOutput {
	return o.ApplyT(func(v Release) map[string]interface{} { return v.Manifest }).(pulumi.MapOutput)
}

// Limit the maximum number of revisions saved per release. Use 0 for no limit.
func (o ReleaseOutput) MaxHistory() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Release) *int { return v.MaxHistory }).(pulumi.IntPtrOutput)
}

// Release name.
func (o ReleaseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace to install the release into.
func (o ReleaseOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Postrender command to run.
func (o ReleaseOutput) Postrender() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Postrender }).(pulumi.StringPtrOutput)
}

// Perform pods restart during upgrade/rollback.
func (o ReleaseOutput) RecreatePods() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.RecreatePods }).(pulumi.BoolPtrOutput)
}

// If set, render subchart notes along with the parent.
func (o ReleaseOutput) RenderSubchartNotes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.RenderSubchartNotes }).(pulumi.BoolPtrOutput)
}

// Re-use the given name, even if that name is already used. This is unsafe in production
func (o ReleaseOutput) Replace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.Replace }).(pulumi.BoolPtrOutput)
}

// Specification defining the Helm chart repository to use.
func (o ReleaseOutput) RepositoryOpts() RepositoryOptsPtrOutput {
	return o.ApplyT(func(v Release) *RepositoryOpts { return v.RepositoryOpts }).(RepositoryOptsPtrOutput)
}

// When upgrading, reset the values to the ones built into the chart.
func (o ReleaseOutput) ResetValues() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.ResetValues }).(pulumi.BoolPtrOutput)
}

// Names of resources created by the release grouped by "kind/version".
func (o ReleaseOutput) ResourceNames() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v Release) map[string][]string { return v.ResourceNames }).(pulumi.StringArrayMapOutput)
}

// When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
func (o ReleaseOutput) ReuseValues() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.ReuseValues }).(pulumi.BoolPtrOutput)
}

// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
func (o ReleaseOutput) SkipAwait() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.SkipAwait }).(pulumi.BoolPtrOutput)
}

// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
func (o ReleaseOutput) SkipCrds() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.SkipCrds }).(pulumi.BoolPtrOutput)
}

// Time in seconds to wait for any individual kubernetes operation.
func (o ReleaseOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v Release) *int { return v.Timeout }).(pulumi.IntPtrOutput)
}

// List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
func (o ReleaseOutput) ValueYamlFiles() pulumi.AssetOrArchiveArrayOutput {
	return o.ApplyT(func(v Release) []pulumi.AssetOrArchive { return v.ValueYamlFiles }).(pulumi.AssetOrArchiveArrayOutput)
}

// Custom values set for the release.
func (o ReleaseOutput) Values() pulumi.MapOutput {
	return o.ApplyT(func(v Release) map[string]interface{} { return v.Values }).(pulumi.MapOutput)
}

// Verify the package before installing it.
func (o ReleaseOutput) Verify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.Verify }).(pulumi.BoolPtrOutput)
}

// Specify the exact chart version to install. If this is not specified, the latest version is installed.
func (o ReleaseOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Release) *string { return v.Version }).(pulumi.StringPtrOutput)
}

// Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
func (o ReleaseOutput) WaitForJobs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Release) *bool { return v.WaitForJobs }).(pulumi.BoolPtrOutput)
}

type ReleasePtrOutput struct{ *pulumi.OutputState }

func (ReleasePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Release)(nil)).Elem()
}

func (o ReleasePtrOutput) ToReleasePtrOutput() ReleasePtrOutput {
	return o
}

func (o ReleasePtrOutput) ToReleasePtrOutputWithContext(ctx context.Context) ReleasePtrOutput {
	return o
}

func (o ReleasePtrOutput) Elem() ReleaseOutput {
	return o.ApplyT(func(v *Release) Release {
		if v != nil {
			return *v
		}
		var ret Release
		return ret
	}).(ReleaseOutput)
}

// If set, installation process purges chart on fail. `skipAwait` will be disabled automatically if atomic is used.
func (o ReleasePtrOutput) Atomic() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.Atomic
	}).(pulumi.BoolPtrOutput)
}

// Chart name to be installed. A path may be used.
func (o ReleasePtrOutput) Chart() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Chart
	}).(pulumi.StringPtrOutput)
}

// Allow deletion of new resources created in this upgrade when upgrade fails.
func (o ReleasePtrOutput) CleanupOnFail() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.CleanupOnFail
	}).(pulumi.BoolPtrOutput)
}

// Create the namespace if it does not exist.
func (o ReleasePtrOutput) CreateNamespace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.CreateNamespace
	}).(pulumi.BoolPtrOutput)
}

// Run helm dependency update before installing the chart.
func (o ReleasePtrOutput) DependencyUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.DependencyUpdate
	}).(pulumi.BoolPtrOutput)
}

// Add a custom description
func (o ReleasePtrOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Description
	}).(pulumi.StringPtrOutput)
}

// Use chart development versions, too. Equivalent to version '>0.0.0-0'. If `version` is set, this is ignored.
func (o ReleasePtrOutput) Devel() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.Devel
	}).(pulumi.BoolPtrOutput)
}

// Prevent CRD hooks from, running, but run other hooks.  See helm install --no-crd-hook
func (o ReleasePtrOutput) DisableCRDHooks() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.DisableCRDHooks
	}).(pulumi.BoolPtrOutput)
}

// If set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
func (o ReleasePtrOutput) DisableOpenapiValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.DisableOpenapiValidation
	}).(pulumi.BoolPtrOutput)
}

// Prevent hooks from running.
func (o ReleasePtrOutput) DisableWebhooks() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.DisableWebhooks
	}).(pulumi.BoolPtrOutput)
}

// Force resource update through delete/recreate if needed.
func (o ReleasePtrOutput) ForceUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.ForceUpdate
	}).(pulumi.BoolPtrOutput)
}

// Location of public keys used for verification. Used only if `verify` is true
func (o ReleasePtrOutput) Keyring() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Keyring
	}).(pulumi.StringPtrOutput)
}

// Run helm lint when planning.
func (o ReleasePtrOutput) Lint() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.Lint
	}).(pulumi.BoolPtrOutput)
}

// The rendered manifests as JSON. Not yet supported.
func (o ReleasePtrOutput) Manifest() pulumi.MapOutput {
	return o.ApplyT(func(v *Release) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Manifest
	}).(pulumi.MapOutput)
}

// Limit the maximum number of revisions saved per release. Use 0 for no limit.
func (o ReleasePtrOutput) MaxHistory() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Release) *int {
		if v == nil {
			return nil
		}
		return v.MaxHistory
	}).(pulumi.IntPtrOutput)
}

// Release name.
func (o ReleasePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace to install the release into.
func (o ReleasePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Postrender command to run.
func (o ReleasePtrOutput) Postrender() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Postrender
	}).(pulumi.StringPtrOutput)
}

// Perform pods restart during upgrade/rollback.
func (o ReleasePtrOutput) RecreatePods() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.RecreatePods
	}).(pulumi.BoolPtrOutput)
}

// If set, render subchart notes along with the parent.
func (o ReleasePtrOutput) RenderSubchartNotes() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.RenderSubchartNotes
	}).(pulumi.BoolPtrOutput)
}

// Re-use the given name, even if that name is already used. This is unsafe in production
func (o ReleasePtrOutput) Replace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.Replace
	}).(pulumi.BoolPtrOutput)
}

// Specification defining the Helm chart repository to use.
func (o ReleasePtrOutput) RepositoryOpts() RepositoryOptsPtrOutput {
	return o.ApplyT(func(v *Release) *RepositoryOpts {
		if v == nil {
			return nil
		}
		return v.RepositoryOpts
	}).(RepositoryOptsPtrOutput)
}

// When upgrading, reset the values to the ones built into the chart.
func (o ReleasePtrOutput) ResetValues() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.ResetValues
	}).(pulumi.BoolPtrOutput)
}

// Names of resources created by the release grouped by "kind/version".
func (o ReleasePtrOutput) ResourceNames() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v *Release) map[string][]string {
		if v == nil {
			return nil
		}
		return v.ResourceNames
	}).(pulumi.StringArrayMapOutput)
}

// When upgrading, reuse the last release's values and merge in any overrides. If 'resetValues' is specified, this is ignored
func (o ReleasePtrOutput) ReuseValues() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.ReuseValues
	}).(pulumi.BoolPtrOutput)
}

// By default, the provider waits until all resources are in a ready state before marking the release as successful. Setting this to true will skip such await logic.
func (o ReleasePtrOutput) SkipAwait() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.SkipAwait
	}).(pulumi.BoolPtrOutput)
}

// If set, no CRDs will be installed. By default, CRDs are installed if not already present.
func (o ReleasePtrOutput) SkipCrds() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.SkipCrds
	}).(pulumi.BoolPtrOutput)
}

// Time in seconds to wait for any individual kubernetes operation.
func (o ReleasePtrOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Release) *int {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.IntPtrOutput)
}

// List of assets (raw yaml files). Content is read and merged with values. Not yet supported.
func (o ReleasePtrOutput) ValueYamlFiles() pulumi.AssetOrArchiveArrayOutput {
	return o.ApplyT(func(v *Release) []pulumi.AssetOrArchive {
		if v == nil {
			return nil
		}
		return v.ValueYamlFiles
	}).(pulumi.AssetOrArchiveArrayOutput)
}

// Custom values set for the release.
func (o ReleasePtrOutput) Values() pulumi.MapOutput {
	return o.ApplyT(func(v *Release) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Values
	}).(pulumi.MapOutput)
}

// Verify the package before installing it.
func (o ReleasePtrOutput) Verify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.Verify
	}).(pulumi.BoolPtrOutput)
}

// Specify the exact chart version to install. If this is not specified, the latest version is installed.
func (o ReleasePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Release) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Will wait until all Jobs have been completed before marking the release as successful. This is ignored if `skipAwait` is enabled.
func (o ReleasePtrOutput) WaitForJobs() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Release) *bool {
		if v == nil {
			return nil
		}
		return v.WaitForJobs
	}).(pulumi.BoolPtrOutput)
}

type ReleaseStatus struct {
	// The version number of the application being deployed.
	AppVersion string `pulumi:"appVersion"`
	// The name of the chart.
	Chart string `pulumi:"chart"`
	// Name is the name of the release.
	Name string `pulumi:"name"`
	// Namespace is the kubernetes namespace of the release.
	Namespace string `pulumi:"namespace"`
	// Version is an int32 which represents the version of the release.
	Revision int `pulumi:"revision"`
	// Status of the release.
	Status string `pulumi:"status"`
	// A SemVer 2 conformant version string of the chart.
	Version string `pulumi:"version"`
}

// ReleaseStatusInput is an input type that accepts ReleaseStatusArgs and ReleaseStatusOutput values.
// You can construct a concrete instance of `ReleaseStatusInput` via:
//
//          ReleaseStatusArgs{...}
type ReleaseStatusInput interface {
	pulumi.Input

	ToReleaseStatusOutput() ReleaseStatusOutput
	ToReleaseStatusOutputWithContext(context.Context) ReleaseStatusOutput
}

type ReleaseStatusArgs struct {
	// The version number of the application being deployed.
	AppVersion pulumi.StringInput `pulumi:"appVersion"`
	// The name of the chart.
	Chart pulumi.StringInput `pulumi:"chart"`
	// Name is the name of the release.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the kubernetes namespace of the release.
	Namespace pulumi.StringInput `pulumi:"namespace"`
	// Version is an int32 which represents the version of the release.
	Revision pulumi.IntInput `pulumi:"revision"`
	// Status of the release.
	Status pulumi.StringInput `pulumi:"status"`
	// A SemVer 2 conformant version string of the chart.
	Version pulumi.StringInput `pulumi:"version"`
}

func (ReleaseStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReleaseStatus)(nil)).Elem()
}

func (i ReleaseStatusArgs) ToReleaseStatusOutput() ReleaseStatusOutput {
	return i.ToReleaseStatusOutputWithContext(context.Background())
}

func (i ReleaseStatusArgs) ToReleaseStatusOutputWithContext(ctx context.Context) ReleaseStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseStatusOutput)
}

func (i ReleaseStatusArgs) ToReleaseStatusPtrOutput() ReleaseStatusPtrOutput {
	return i.ToReleaseStatusPtrOutputWithContext(context.Background())
}

func (i ReleaseStatusArgs) ToReleaseStatusPtrOutputWithContext(ctx context.Context) ReleaseStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseStatusOutput).ToReleaseStatusPtrOutputWithContext(ctx)
}

// ReleaseStatusPtrInput is an input type that accepts ReleaseStatusArgs, ReleaseStatusPtr and ReleaseStatusPtrOutput values.
// You can construct a concrete instance of `ReleaseStatusPtrInput` via:
//
//          ReleaseStatusArgs{...}
//
//  or:
//
//          nil
type ReleaseStatusPtrInput interface {
	pulumi.Input

	ToReleaseStatusPtrOutput() ReleaseStatusPtrOutput
	ToReleaseStatusPtrOutputWithContext(context.Context) ReleaseStatusPtrOutput
}

type releaseStatusPtrType ReleaseStatusArgs

func ReleaseStatusPtr(v *ReleaseStatusArgs) ReleaseStatusPtrInput {
	return (*releaseStatusPtrType)(v)
}

func (*releaseStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReleaseStatus)(nil)).Elem()
}

func (i *releaseStatusPtrType) ToReleaseStatusPtrOutput() ReleaseStatusPtrOutput {
	return i.ToReleaseStatusPtrOutputWithContext(context.Background())
}

func (i *releaseStatusPtrType) ToReleaseStatusPtrOutputWithContext(ctx context.Context) ReleaseStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseStatusPtrOutput)
}

type ReleaseStatusOutput struct{ *pulumi.OutputState }

func (ReleaseStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReleaseStatus)(nil)).Elem()
}

func (o ReleaseStatusOutput) ToReleaseStatusOutput() ReleaseStatusOutput {
	return o
}

func (o ReleaseStatusOutput) ToReleaseStatusOutputWithContext(ctx context.Context) ReleaseStatusOutput {
	return o
}

func (o ReleaseStatusOutput) ToReleaseStatusPtrOutput() ReleaseStatusPtrOutput {
	return o.ToReleaseStatusPtrOutputWithContext(context.Background())
}

func (o ReleaseStatusOutput) ToReleaseStatusPtrOutputWithContext(ctx context.Context) ReleaseStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReleaseStatus) *ReleaseStatus {
		return &v
	}).(ReleaseStatusPtrOutput)
}

// The version number of the application being deployed.
func (o ReleaseStatusOutput) AppVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ReleaseStatus) string { return v.AppVersion }).(pulumi.StringOutput)
}

// The name of the chart.
func (o ReleaseStatusOutput) Chart() pulumi.StringOutput {
	return o.ApplyT(func(v ReleaseStatus) string { return v.Chart }).(pulumi.StringOutput)
}

// Name is the name of the release.
func (o ReleaseStatusOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ReleaseStatus) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the kubernetes namespace of the release.
func (o ReleaseStatusOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v ReleaseStatus) string { return v.Namespace }).(pulumi.StringOutput)
}

// Version is an int32 which represents the version of the release.
func (o ReleaseStatusOutput) Revision() pulumi.IntOutput {
	return o.ApplyT(func(v ReleaseStatus) int { return v.Revision }).(pulumi.IntOutput)
}

// Status of the release.
func (o ReleaseStatusOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v ReleaseStatus) string { return v.Status }).(pulumi.StringOutput)
}

// A SemVer 2 conformant version string of the chart.
func (o ReleaseStatusOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v ReleaseStatus) string { return v.Version }).(pulumi.StringOutput)
}

type ReleaseStatusPtrOutput struct{ *pulumi.OutputState }

func (ReleaseStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReleaseStatus)(nil)).Elem()
}

func (o ReleaseStatusPtrOutput) ToReleaseStatusPtrOutput() ReleaseStatusPtrOutput {
	return o
}

func (o ReleaseStatusPtrOutput) ToReleaseStatusPtrOutputWithContext(ctx context.Context) ReleaseStatusPtrOutput {
	return o
}

func (o ReleaseStatusPtrOutput) Elem() ReleaseStatusOutput {
	return o.ApplyT(func(v *ReleaseStatus) ReleaseStatus {
		if v != nil {
			return *v
		}
		var ret ReleaseStatus
		return ret
	}).(ReleaseStatusOutput)
}

// The version number of the application being deployed.
func (o ReleaseStatusPtrOutput) AppVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *string {
		if v == nil {
			return nil
		}
		return &v.AppVersion
	}).(pulumi.StringPtrOutput)
}

// The name of the chart.
func (o ReleaseStatusPtrOutput) Chart() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Chart
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the release.
func (o ReleaseStatusPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the kubernetes namespace of the release.
func (o ReleaseStatusPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Version is an int32 which represents the version of the release.
func (o ReleaseStatusPtrOutput) Revision() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *int {
		if v == nil {
			return nil
		}
		return &v.Revision
	}).(pulumi.IntPtrOutput)
}

// Status of the release.
func (o ReleaseStatusPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Status
	}).(pulumi.StringPtrOutput)
}

// A SemVer 2 conformant version string of the chart.
func (o ReleaseStatusPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseStatus) *string {
		if v == nil {
			return nil
		}
		return &v.Version
	}).(pulumi.StringPtrOutput)
}

// Specification defining the Helm chart repository to use.
type RepositoryOpts struct {
	// The Repository's CA File
	CaFile *string `pulumi:"caFile"`
	// The repository's cert file
	CertFile *string `pulumi:"certFile"`
	// The repository's cert key file
	KeyFile *string `pulumi:"keyFile"`
	// Password for HTTP basic authentication
	Password *string `pulumi:"password"`
	// Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
	Repo *string `pulumi:"repo"`
	// Username for HTTP basic authentication
	Username *string `pulumi:"username"`
}

// RepositoryOptsInput is an input type that accepts RepositoryOptsArgs and RepositoryOptsOutput values.
// You can construct a concrete instance of `RepositoryOptsInput` via:
//
//          RepositoryOptsArgs{...}
type RepositoryOptsInput interface {
	pulumi.Input

	ToRepositoryOptsOutput() RepositoryOptsOutput
	ToRepositoryOptsOutputWithContext(context.Context) RepositoryOptsOutput
}

// Specification defining the Helm chart repository to use.
type RepositoryOptsArgs struct {
	// The Repository's CA File
	CaFile pulumi.StringPtrInput `pulumi:"caFile"`
	// The repository's cert file
	CertFile pulumi.StringPtrInput `pulumi:"certFile"`
	// The repository's cert key file
	KeyFile pulumi.StringPtrInput `pulumi:"keyFile"`
	// Password for HTTP basic authentication
	Password pulumi.StringPtrInput `pulumi:"password"`
	// Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
	Repo pulumi.StringPtrInput `pulumi:"repo"`
	// Username for HTTP basic authentication
	Username pulumi.StringPtrInput `pulumi:"username"`
}

func (RepositoryOptsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryOpts)(nil)).Elem()
}

func (i RepositoryOptsArgs) ToRepositoryOptsOutput() RepositoryOptsOutput {
	return i.ToRepositoryOptsOutputWithContext(context.Background())
}

func (i RepositoryOptsArgs) ToRepositoryOptsOutputWithContext(ctx context.Context) RepositoryOptsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryOptsOutput)
}

func (i RepositoryOptsArgs) ToRepositoryOptsPtrOutput() RepositoryOptsPtrOutput {
	return i.ToRepositoryOptsPtrOutputWithContext(context.Background())
}

func (i RepositoryOptsArgs) ToRepositoryOptsPtrOutputWithContext(ctx context.Context) RepositoryOptsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryOptsOutput).ToRepositoryOptsPtrOutputWithContext(ctx)
}

// RepositoryOptsPtrInput is an input type that accepts RepositoryOptsArgs, RepositoryOptsPtr and RepositoryOptsPtrOutput values.
// You can construct a concrete instance of `RepositoryOptsPtrInput` via:
//
//          RepositoryOptsArgs{...}
//
//  or:
//
//          nil
type RepositoryOptsPtrInput interface {
	pulumi.Input

	ToRepositoryOptsPtrOutput() RepositoryOptsPtrOutput
	ToRepositoryOptsPtrOutputWithContext(context.Context) RepositoryOptsPtrOutput
}

type repositoryOptsPtrType RepositoryOptsArgs

func RepositoryOptsPtr(v *RepositoryOptsArgs) RepositoryOptsPtrInput {
	return (*repositoryOptsPtrType)(v)
}

func (*repositoryOptsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryOpts)(nil)).Elem()
}

func (i *repositoryOptsPtrType) ToRepositoryOptsPtrOutput() RepositoryOptsPtrOutput {
	return i.ToRepositoryOptsPtrOutputWithContext(context.Background())
}

func (i *repositoryOptsPtrType) ToRepositoryOptsPtrOutputWithContext(ctx context.Context) RepositoryOptsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryOptsPtrOutput)
}

// Specification defining the Helm chart repository to use.
type RepositoryOptsOutput struct{ *pulumi.OutputState }

func (RepositoryOptsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryOpts)(nil)).Elem()
}

func (o RepositoryOptsOutput) ToRepositoryOptsOutput() RepositoryOptsOutput {
	return o
}

func (o RepositoryOptsOutput) ToRepositoryOptsOutputWithContext(ctx context.Context) RepositoryOptsOutput {
	return o
}

func (o RepositoryOptsOutput) ToRepositoryOptsPtrOutput() RepositoryOptsPtrOutput {
	return o.ToRepositoryOptsPtrOutputWithContext(context.Background())
}

func (o RepositoryOptsOutput) ToRepositoryOptsPtrOutputWithContext(ctx context.Context) RepositoryOptsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RepositoryOpts) *RepositoryOpts {
		return &v
	}).(RepositoryOptsPtrOutput)
}

// The Repository's CA File
func (o RepositoryOptsOutput) CaFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryOpts) *string { return v.CaFile }).(pulumi.StringPtrOutput)
}

// The repository's cert file
func (o RepositoryOptsOutput) CertFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryOpts) *string { return v.CertFile }).(pulumi.StringPtrOutput)
}

// The repository's cert key file
func (o RepositoryOptsOutput) KeyFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryOpts) *string { return v.KeyFile }).(pulumi.StringPtrOutput)
}

// Password for HTTP basic authentication
func (o RepositoryOptsOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryOpts) *string { return v.Password }).(pulumi.StringPtrOutput)
}

// Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
func (o RepositoryOptsOutput) Repo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryOpts) *string { return v.Repo }).(pulumi.StringPtrOutput)
}

// Username for HTTP basic authentication
func (o RepositoryOptsOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryOpts) *string { return v.Username }).(pulumi.StringPtrOutput)
}

type RepositoryOptsPtrOutput struct{ *pulumi.OutputState }

func (RepositoryOptsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryOpts)(nil)).Elem()
}

func (o RepositoryOptsPtrOutput) ToRepositoryOptsPtrOutput() RepositoryOptsPtrOutput {
	return o
}

func (o RepositoryOptsPtrOutput) ToRepositoryOptsPtrOutputWithContext(ctx context.Context) RepositoryOptsPtrOutput {
	return o
}

func (o RepositoryOptsPtrOutput) Elem() RepositoryOptsOutput {
	return o.ApplyT(func(v *RepositoryOpts) RepositoryOpts {
		if v != nil {
			return *v
		}
		var ret RepositoryOpts
		return ret
	}).(RepositoryOptsOutput)
}

// The Repository's CA File
func (o RepositoryOptsPtrOutput) CaFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryOpts) *string {
		if v == nil {
			return nil
		}
		return v.CaFile
	}).(pulumi.StringPtrOutput)
}

// The repository's cert file
func (o RepositoryOptsPtrOutput) CertFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryOpts) *string {
		if v == nil {
			return nil
		}
		return v.CertFile
	}).(pulumi.StringPtrOutput)
}

// The repository's cert key file
func (o RepositoryOptsPtrOutput) KeyFile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryOpts) *string {
		if v == nil {
			return nil
		}
		return v.KeyFile
	}).(pulumi.StringPtrOutput)
}

// Password for HTTP basic authentication
func (o RepositoryOptsPtrOutput) Password() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryOpts) *string {
		if v == nil {
			return nil
		}
		return v.Password
	}).(pulumi.StringPtrOutput)
}

// Repository where to locate the requested chart. If is a URL the chart is installed without installing the repository.
func (o RepositoryOptsPtrOutput) Repo() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryOpts) *string {
		if v == nil {
			return nil
		}
		return v.Repo
	}).(pulumi.StringPtrOutput)
}

// Username for HTTP basic authentication
func (o RepositoryOptsPtrOutput) Username() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryOpts) *string {
		if v == nil {
			return nil
		}
		return v.Username
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(CoreDNSAutoscalerOutput{})
	pulumi.RegisterOutputType(CoreDNSAutoscalerPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSDeploymentOutput{})
	pulumi.RegisterOutputType(CoreDNSDeploymentPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSHPAOutput{})
	pulumi.RegisterOutputType(CoreDNSHPAPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSImageOutput{})
	pulumi.RegisterOutputType(CoreDNSImagePtrOutput{})
	pulumi.RegisterOutputType(CoreDNSPrometheusOutput{})
	pulumi.RegisterOutputType(CoreDNSPrometheusPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSPrometheusMonitorOutput{})
	pulumi.RegisterOutputType(CoreDNSPrometheusMonitorPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSPrometheusServiceOutput{})
	pulumi.RegisterOutputType(CoreDNSPrometheusServicePtrOutput{})
	pulumi.RegisterOutputType(CoreDNSRBACOutput{})
	pulumi.RegisterOutputType(CoreDNSRBACPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSServerOutput{})
	pulumi.RegisterOutputType(CoreDNSServerArrayOutput{})
	pulumi.RegisterOutputType(CoreDNSServerPluginOutput{})
	pulumi.RegisterOutputType(CoreDNSServerPluginArrayOutput{})
	pulumi.RegisterOutputType(CoreDNSServerZoneOutput{})
	pulumi.RegisterOutputType(CoreDNSServerZoneArrayOutput{})
	pulumi.RegisterOutputType(CoreDNSServiceOutput{})
	pulumi.RegisterOutputType(CoreDNSServicePtrOutput{})
	pulumi.RegisterOutputType(CoreDNSServiceAccountOutput{})
	pulumi.RegisterOutputType(CoreDNSServiceAccountPtrOutput{})
	pulumi.RegisterOutputType(CoreDNSZoneFileOutput{})
	pulumi.RegisterOutputType(CoreDNSZoneFileArrayOutput{})
	pulumi.RegisterOutputType(ReleaseOutput{})
	pulumi.RegisterOutputType(ReleasePtrOutput{})
	pulumi.RegisterOutputType(ReleaseStatusOutput{})
	pulumi.RegisterOutputType(ReleaseStatusPtrOutput{})
	pulumi.RegisterOutputType(RepositoryOptsOutput{})
	pulumi.RegisterOutputType(RepositoryOptsPtrOutput{})
}
